(function () {
	'use strict';

	let adapter;
	let device;
	const clearColor = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };
	let format;
	let canvas;
	let context;
	let depth;
	let cameraBuffer;
	let renderPass;
	let encoder;
	function aspect() {
	    return canvas.width / canvas.height;
	}
	async function Setup$2(width, height) {
	    if (window.navigator.gpu == undefined) {
	        return undefined;
	    }
	    adapter = await window.navigator.gpu.requestAdapter();
	    if (adapter == null) {
	        return undefined;
	    }
	    device = await adapter.requestDevice();
	    if (device == null) {
	        return undefined;
	    }
	    canvas = document.createElement('canvas');
	    context = canvas.getContext('webgpu');
	    format = context.getPreferredFormat(adapter);
	    Resize(width, height);
	    return canvas;
	}
	function Resize(width, height) {
	    context.configure({
	        device: device,
	        format: format,
	        size: { width: width, height: height },
	    });
	    canvas.width = width;
	    canvas.height = height;
	    depth = device.createTexture({
	        size: {
	            width: canvas.width,
	            height: canvas.height,
	        },
	        format: 'depth32float',
	        usage: GPUTextureUsage.RENDER_ATTACHMENT,
	    });
	}
	function StartRender(camera) {
	    encoder = device.createCommandEncoder();
	    renderPass = encoder.beginRenderPass({
	        colorAttachments: [
	            {
	                loadValue: clearColor,
	                storeOp: 'store',
	                view: context.getCurrentTexture().createView(),
	            },
	        ],
	        depthStencilAttachment: {
	            depthLoadValue: 1.0,
	            depthStoreOp: 'store',
	            stencilLoadValue: 0,
	            stencilStoreOp: 'store',
	            view: depth.createView(),
	        },
	    });
	    cameraBuffer = camera.Buffer();
	}
	function FinishRender() {
	    renderPass.endPass();
	    device.queue.submit([encoder.finish()]);
	}
	function CreateBuffer(data, usage) {
	    const size = data.byteLength < 80 ? 80 : data.byteLength;
	    const buffer = device.createBuffer({
	        size: size,
	        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC | usage,
	        mappedAtCreation: true,
	    });
	    new Uint8Array(buffer.getMappedRange()).set(new Uint8Array(data.buffer));
	    buffer.unmap();
	    return buffer;
	}
	function CreateEmptyBuffer(length, usage) {
	    const buffer = device.createBuffer({
	        size: length,
	        usage: usage,
	        mappedAtCreation: false,
	    });
	    return buffer;
	}
	async function ReadBuffer(buffer, size) {
	    const temp = CreateEmptyBuffer(size, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
	    const copyEncoder = device.createCommandEncoder();
	    copyEncoder.copyBufferToBuffer(buffer, 0, temp, 0, size);
	    const copyCommands = copyEncoder.finish();
	    device.queue.submit([copyCommands]);
	    await temp.mapAsync(GPUMapMode.READ);
	    const copyArrayBuffer = temp.getMappedRange();
	    return copyArrayBuffer;
	}
	function NewModule(src) {
	    const module = device.createShaderModule({
	        code: src,
	    });
	    return module;
	}
	function ConvertURI(uri) {
	    return window.atob(uri.split(',')[1]);
	}

	var cleanDangURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IG5lYXJlc3Q6IEluZGljZXM7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgd3JpdGU+IG5ld19uZWFyZXN0OiBJbmRpY2VzOwoKbGV0IFBJID0gMy4xNDE1OTI2NTM4OwoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCXZhciB0YXJnZXQgPSAwdTsKCXZhciBvZmYgPSBpZCAqIHBhcmFtZXRlci5rOwoJZm9yICh2YXIgaSA9IDB1OyBpIDwgcGFyYW1ldGVyLms7IGkgPSBpICsgMXUpIHsKCQlsZXQgaWR4ID0gbmVhcmVzdC5kYXRhW2lkICogcGFyYW1ldGVyLmsgKyBpXTsKCQlpZiAoaWR4ID09IGlkKSB7CgkJCWJyZWFrOwoJCX0KCQlsZXQgb2Zmc2V0ID0gaWR4ICogcGFyYW1ldGVyLms7CgkJdmFyIGNvbm5lY3RlZCA9IGZhbHNlOwoJCWZvciAodmFyIGogPSAwdTsgaiA8IHBhcmFtZXRlci5rOyBqID0gaiArIDF1KSB7CgkJCWlmIChuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgal0gPT0gaWQpIHsKCQkJCWNvbm5lY3RlZCA9IHRydWU7CgkJCQlicmVhazsKCQkJfQoJCX0KCQlpZiAoY29ubmVjdGVkKSB7CgkJCW5ld19uZWFyZXN0LmRhdGFbb2ZmICsgdGFyZ2V0XSA9IGlkeDsKCQkJdGFyZ2V0ID0gdGFyZ2V0ICsgMXU7CgkJfQoJfQoJZm9yICg7IHRhcmdldCA8IHBhcmFtZXRlci5rOyB0YXJnZXQgPSB0YXJnZXQgKyAxdSkgewoJCW5ld19uZWFyZXN0LmRhdGFbb2ZmICsgdGFyZ2V0XSA9IGlkOwoJfQp9Cg==";

	var cleanLongURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gbmVhcmVzdDogSW5kaWNlczsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCB3cml0ZT4gbmV3X25lYXJlc3Q6IEluZGljZXM7CgpsZXQgUEkgPSAzLjE0MTU5MjY1Mzg7CgpbW3N0YWdlKGNvbXB1dGUpLCB3b3JrZ3JvdXBfc2l6ZSgyNTYpXV0KZm4gbWFpbihbW2J1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpXV0gZ2xvYmFsIDogdmVjMzx1MzI+KSB7CglpZiAoZ2xvYmFsLnggPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCWxldCBpZCA9IGdsb2JhbC54OwoJdmFyIHAgPSBjbG91ZC5kYXRhW2lkXTsKCXZhciBhdmcgPSAwLjA7Cgl2YXIgY291bnQgPSAwdTsKCWZvciAoOyBjb3VudCA8IHBhcmFtZXRlci5rOyBjb3VudCA9IGNvdW50ICsgMXUpIHsKCQlsZXQgbyA9IG5lYXJlc3QuZGF0YVtpZCpwYXJhbWV0ZXIuayArIGNvdW50XTsKCQlpZiAobyA9PSBpZCkgewoJCQlicmVhazsKCQl9CgkJYXZnID0gYXZnICsgZGlzdGFuY2UocCwgY2xvdWQuZGF0YVtvXSk7Cgl9CglhdmcgPSBhdmcgLyBmMzIoY291bnQpICogMy4wOwoKCXZhciBpZHggPSAwdTsKCWZvciAodmFyIGkgPSAwdTsgaSA8IGNvdW50OyBpID0gaSArIDF1KSB7CgkJbGV0IG8gPSBuZWFyZXN0LmRhdGFbaWQqcGFyYW1ldGVyLmsgKyBpXTsKCQlpZiAoZGlzdGFuY2UocCwgY2xvdWQuZGF0YVtvXSkgPD0gYXZnKSB7CgkJCW5ld19uZWFyZXN0LmRhdGFbaWQqcGFyYW1ldGVyLmsgKyBpZHhdID0gbzsKCQkJaWR4ID0gaWR4ICsgMXU7CgkJfQoJfQoJZm9yICg7aWR4IDwgcGFyYW1ldGVyLms7IGlkeCA9IGlkeCArIDF1KSB7CgkJbmV3X25lYXJlc3QuZGF0YVtpZCpwYXJhbWV0ZXIuayArIGlkeF0gPSBpZDsKCX0KfQo=";

	var kNearestListURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpsZXQgTUFYX0RJU1RBTkNFID0gMzQwMjgyMzQ2NjM4NTI4ODU5ODExNzA0MTgzNDg0NTE2OTI1NDQwLjA7IC8vbWF4IHZhbHVlIGZvciBmMzIgKGkgdGhpbmspCgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gbmVhcmVzdDogSW5kaWNlczsKCltbc3RhZ2UoY29tcHV0ZSksIHdvcmtncm91cF9zaXplKDI1NildXQpmbiBtYWluKFtbYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCldXSBnbG9iYWwgOiB2ZWMzPHUzMj4pIHsKCWxldCBpZCA9IGdsb2JhbC54OwoJaWYgKGlkID49IHBhcmFtZXRlci5sZW5ndGgpIHsKCQlyZXR1cm47Cgl9CglsZXQgb2Zmc2V0ID0gaWQgKiBwYXJhbWV0ZXIuazsKCglsZXQgcG9pbnQgPSBjbG91ZC5kYXRhW2lkXTsKCXZhciBpID0gMHU7Cglmb3IgKHZhciBjb3VudCA9IDB1OyBjb3VudCA8IHBhcmFtZXRlci5rOyBpID0gaSArIDF1KSB7IC8vaW5pdCB0aGUgayB2YWx1ZXMgd2l0aCB0aGUgZmlyc3QgaW4gY2xvdWQKCQlpZiAoaSA9PSBpZCkgewoJCQljb250aW51ZTsKCQl9CgkJbGV0IGQgPSBkaXN0YW5jZShwb2ludCwgY2xvdWQuZGF0YVtpXSk7CgkJdmFyIGlkeCA9IDB1OwoJCWZvciAoOyBpZHggPCBjb3VudDsgaWR4ID0gaWR4ICsgMXUpIHsKCQkJaWYgKGRpc3RhbmNlKHBvaW50LCBjbG91ZC5kYXRhW25lYXJlc3QuZGF0YVtvZmZzZXQgKyBpZHhdIF0pIDwgZCkgewoJCQkJYnJlYWs7CgkJCX0KCQl9CgkJZm9yICh2YXIgeCA9IGNvdW50OyB4ID4gaWR4OyB4ID0geCAtIDF1KSB7CgkJCW5lYXJlc3QuZGF0YVtvZmZzZXQgKyB4XSA9IG5lYXJlc3QuZGF0YVtvZmZzZXQgKyB4IC0gMXVdOwoJCX0KCQluZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaWR4XSA9IGk7CgkJY291bnQgPSBjb3VudCArIDF1OwoJfQoJdmFyIGRpc3QgPSBkaXN0YW5jZShwb2ludCwgY2xvdWQuZGF0YVtuZWFyZXN0LmRhdGFbb2Zmc2V0XSBdKTsKCWZvciAoOyBpIDwgcGFyYW1ldGVyLmxlbmd0aDsgaSA9IGkgKyAxdSkgeyAvL2NoZWNrIHRoZSByZW1haW5pbmcgcG9pbnRzCgkJaWYgKGkgPT0gaWQpIHsKCQkJY29udGludWU7CgkJfQoJCWxldCBkID0gZGlzdGFuY2UocG9pbnQsIGNsb3VkLmRhdGFbaV0pOwoJCWlmIChkIDwgZGlzdCkgewoJCQl2YXIgaWR4ID0gMHU7CgkJCWZvciAoOyBpZHggPCBwYXJhbWV0ZXIuayAtIDF1OyBpZHggPSBpZHggKyAxdSkgewoJCQkJaWYgKGRpc3RhbmNlKHBvaW50LCBjbG91ZC5kYXRhW25lYXJlc3QuZGF0YVtvZmZzZXQgKyBpZHggKyAxdV0gXSkgPCBkKSB7CgkJCQkJYnJlYWs7CgkJCQl9CgkJCQluZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaWR4XSA9IG5lYXJlc3QuZGF0YVtvZmZzZXQgKyBpZHggKyAxdV07CgkJCX0KCQkJbmVhcmVzdC5kYXRhW29mZnNldCArIGlkeF0gPSBpOwoJCQlkaXN0ID0gZGlzdGFuY2UocG9pbnQsIGNsb3VkLmRhdGFbbmVhcmVzdC5kYXRhW29mZnNldF0gXSk7CgkJfQoJfQp9Cg==";

	var kNearestIterURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+ID47Cn07CgpbW2Jsb2NrXV0gc3RydWN0IEluZGljZXMgewoJZGF0YTogYXJyYXk8dTMyPjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgUGFyYW1ldGVyIHsKCWxlbmd0aDogdTMyOwoJazogdTMyOwp9OwoKbGV0IE1BWF9ESVNUQU5DRSA9IDM0MDI4MjM0NjYzODUyODg1OTgxMTcwNDE4MzQ4NDUxNjkyNTQ0MC4wOyAvL21heCB2YWx1ZSBmb3IgZjMyIChpIHRoaW5rKQoKW1tncm91cCgwKSwgYmluZGluZygwKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBwYXJhbWV0ZXI6IFBhcmFtZXRlcjsKW1tncm91cCgwKSwgYmluZGluZygxKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBjbG91ZDogQnVmZmVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDIpXV0gdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG5lYXJlc3Q6IEluZGljZXM7CgpbW3N0YWdlKGNvbXB1dGUpLCB3b3JrZ3JvdXBfc2l6ZSgyNTYpXV0KZm4gbWFpbihbW2J1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpXV0gZ2xvYmFsIDogdmVjMzx1MzI+KSB7CglsZXQgaWQgPSBnbG9iYWwueDsKCWlmIChpZCA+PSBwYXJhbWV0ZXIubGVuZ3RoKSB7CgkJcmV0dXJuOwoJfQoJbGV0IG9mZnNldCA9IChpZCArMXUpICogcGFyYW1ldGVyLmsgLSAxdTsKCWxldCBwID0gY2xvdWQuZGF0YVtpZF07Cgl2YXIgbGFzdCA9IDAuMDsKCWZvciAodmFyIGsgPSAwdTsgayA8IHBhcmFtZXRlci5rOyBrID0gayArIDF1KSB7CgkJdmFyIGJlc3Q6IHUzMjsKCQl2YXIgZGlzdCA9IE1BWF9ESVNUQU5DRTsKCQlmb3IgKHZhciBpID0gMHU7IGkgPCBwYXJhbWV0ZXIubGVuZ3RoOyBpID0gaSArIDF1KSB7CgkJCXZhciBkID0gZGlzdGFuY2UocCwgY2xvdWQuZGF0YVtpXSk7CgkJCWlmIChsYXN0IDwgZCAmJiBkIDwgZGlzdCkgewoJCQkJYmVzdCA9IGk7CgkJCQlkaXN0ID0gZDsKCQkJfQoJCX0KCQluZWFyZXN0LmRhdGFbb2Zmc2V0IC0ga10gPSBiZXN0OwoJCWxhc3QgPSBkaXN0OwoJfQp9Cg==";

	var kNearestIterSortedURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpsZXQgTUFYX0RJU1RBTkNFID0gMzQwMjgyMzQ2NjM4NTI4ODU5ODExNzA0MTgzNDg0NTE2OTI1NDQwLjA7IC8vbWF4IHZhbHVlIGZvciBmMzIgKGkgdGhpbmspCgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZF93cml0ZT4gbmVhcmVzdDogSW5kaWNlczsKCgpmbiBnZXRfaW5kZXgoaWQ6IHUzMiwgb2Zmc2V0OiB1MzIpIC0+IHUzMiB7CglpZiAob2Zmc2V0IC8gMnUgPiBpZCkgewoJCXJldHVybiBvZmZzZXQ7Cgl9IGVsc2VpZiAoaWQgKyAob2Zmc2V0KzF1KSAvIDJ1ID49IHBhcmFtZXRlci5sZW5ndGgpIHsKCQlyZXR1cm4gcGFyYW1ldGVyLmxlbmd0aCAtIDF1IC0gb2Zmc2V0OwoJfQoJbGV0IHNpZ24gPSBpMzIob2Zmc2V0ICUgMnUgKiAydSkgLSAxOwoJcmV0dXJuIHUzMihpMzIoaWQpICsgc2lnbiAqIGkzMihvZmZzZXQgKyAxdSkgLyAyKTsKfQoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCWxldCBvZmZzZXQgPSAoaWQgKyAxdSkgKiBwYXJhbWV0ZXIuayAtIDF1OwoJbGV0IHAgPSBjbG91ZC5kYXRhW2lkXTsKCXZhciBsYXN0ID0gMC4wOwoJZm9yICh2YXIgayA9IDB1OyBrIDwgcGFyYW1ldGVyLms7IGsgPSBrICsgMXUpIHsKCQl2YXIgYmVzdDogdTMyOwoJCXZhciBkaXN0ID0gTUFYX0RJU1RBTkNFOwoJCWZvciAodmFyIGkgPSAxdTsgaSA8IHBhcmFtZXRlci5sZW5ndGg7IGkgPSBpICsgMXUpIHsKCQkJbGV0IGlkeCA9IGdldF9pbmRleChpZCwgaSk7CgkJCWxldCBvdGhlciA9IGNsb3VkLmRhdGFbaWR4XTsKCQkJaWYgKGFicyhwLnggLSBvdGhlci54KSA+IGRpc3QpIHsKCQkJCWJyZWFrOwoJCQl9CgkJCXZhciBkID0gZGlzdGFuY2UocCwgb3RoZXIpOwoJCQlpZiAobGFzdCA8IGQgJiYgZCA8IGRpc3QpIHsKCQkJCWJlc3QgPSBpZHg7CgkJCQlkaXN0ID0gZDsKCQkJfQoJCX0KCQluZWFyZXN0LmRhdGFbb2Zmc2V0IC0ga10gPSBiZXN0OwoJCWxhc3QgPSBkaXN0OwoJfQp9Cg==";

	var kNearestListSortedURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpsZXQgTUFYX0RJU1RBTkNFID0gMzQwMjgyMzQ2NjM4NTI4ODU5ODExNzA0MTgzNDg0NTE2OTI1NDQwLjA7IC8vbWF4IHZhbHVlIGZvciBmMzIgKGluZGV4IHRoaW5rKQoKW1tncm91cCgwKSwgYmluZGluZygwKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBwYXJhbWV0ZXI6IFBhcmFtZXRlcjsKW1tncm91cCgwKSwgYmluZGluZygxKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBjbG91ZDogQnVmZmVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDIpXV0gdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG5lYXJlc3Q6IEluZGljZXM7CgpmbiBnZXRfaW5kZXgoaWQ6IHUzMiwgb2Zmc2V0OiB1MzIpIC0+IHUzMiB7CglpZiAob2Zmc2V0IC8gMnUgPiBpZCkgewoJCXJldHVybiBvZmZzZXQ7Cgl9IGVsc2VpZiAoaWQgKyAob2Zmc2V0KzF1KSAvIDJ1ID49IHBhcmFtZXRlci5sZW5ndGgpIHsKCQlyZXR1cm4gcGFyYW1ldGVyLmxlbmd0aCAtIDF1IC0gb2Zmc2V0OwoJfQoJbGV0IHNpZ24gPSBpMzIob2Zmc2V0ICUgMnUgKiAydSkgLSAxOwoJcmV0dXJuIHUzMihpMzIoaWQpICsgc2lnbiAqIGkzMihvZmZzZXQgKyAxdSkgLyAyKTsKfQoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCWxldCBvZmZzZXQgPSBpZCAqIHBhcmFtZXRlci5rOwoKCWxldCBwb2ludCA9IGNsb3VkLmRhdGFbaWRdOwoJdmFyIGluZGV4ID0gMXU7Cglmb3IgKHZhciBjb3VudCA9IDB1OyBjb3VudCA8IHBhcmFtZXRlci5rOyBpbmRleCA9IGluZGV4ICsgMXUpIHsgLy9pbml0IHRoZSBrIHZhbHVlcyB3aXRoIHRoZSBmaXJzdCBpbiBjbG91ZAoJCWxldCBpID0gZ2V0X2luZGV4KGlkLCBpbmRleCk7CgkJbGV0IGQgPSBkaXN0YW5jZShwb2ludCwgY2xvdWQuZGF0YVtpXSk7CgkJdmFyIGlkeCA9IDB1OwoJCWZvciAoOyBpZHggPCBjb3VudDsgaWR4ID0gaWR4ICsgMXUpIHsKCQkJaWYgKGRpc3RhbmNlKHBvaW50LCBjbG91ZC5kYXRhW25lYXJlc3QuZGF0YVtvZmZzZXQgKyBpZHhdIF0pIDwgZCkgewoJCQkJYnJlYWs7CgkJCX0KCQl9CgkJZm9yICh2YXIgeCA9IGNvdW50OyB4ID4gaWR4OyB4ID0geCAtIDF1KSB7CgkJCW5lYXJlc3QuZGF0YVtvZmZzZXQgKyB4XSA9IG5lYXJlc3QuZGF0YVtvZmZzZXQgKyB4IC0gMXVdOwoJCX0KCQluZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaWR4XSA9IGk7CgkJY291bnQgPSBjb3VudCArIDF1OwoJfQoJdmFyIGRpc3QgPSBkaXN0YW5jZShwb2ludCwgY2xvdWQuZGF0YVtuZWFyZXN0LmRhdGFbb2Zmc2V0XSBdKTsKCWZvciAoOyBpbmRleCA8IHBhcmFtZXRlci5sZW5ndGg7IGluZGV4ID0gaW5kZXggKyAxdSkgeyAvL2NoZWNrIHRoZSByZW1haW5pbmcgcG9pbnRzCgkJbGV0IGkgPSBnZXRfaW5kZXgoaWQsIGluZGV4KTsKCQlsZXQgb3RoZXIgPSBjbG91ZC5kYXRhW2ldOwoJCWlmIChhYnMocG9pbnQueCAtIG90aGVyLngpID4gZGlzdCkgewoJCQlicmVhazsKCQl9CgkJbGV0IGQgPSBkaXN0YW5jZShwb2ludCwgb3RoZXIpOwoJCWlmIChkIDwgZGlzdCkgewoJCQl2YXIgaWR4ID0gMHU7CgkJCWZvciAoOyBpZHggPCBwYXJhbWV0ZXIuayAtIDF1OyBpZHggPSBpZHggKyAxdSkgewoJCQkJaWYgKGRpc3RhbmNlKHBvaW50LCBjbG91ZC5kYXRhW25lYXJlc3QuZGF0YVtvZmZzZXQgKyBpZHggKyAxdV0gXSkgPCBkKSB7CgkJCQkJYnJlYWs7CgkJCQl9CgkJCQluZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaWR4XSA9IG5lYXJlc3QuZGF0YVtvZmZzZXQgKyBpZHggKyAxdV07CgkJCX0KCQkJbmVhcmVzdC5kYXRhW29mZnNldCArIGlkeF0gPSBpOwoJCQlkaXN0ID0gZGlzdGFuY2UocG9pbnQsIGNsb3VkLmRhdGFbbmVhcmVzdC5kYXRhW29mZnNldF0gXSk7CgkJfQoJfQp9Cg==";

	var normalLinearURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gbmVhcmVzdDogSW5kaWNlczsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCB3cml0ZT4gY29sb3JzOiBCdWZmZXI7CgpsZXQgUEkgPSAzLjE0MTU5MjY1Mzg7CgpmbiBpbnZlcnNlKG06IG1hdDN4MzxmMzI+KSAtPiBtYXQzeDM8ZjMyPiB7CglsZXQgZGV0ID0gZGV0ZXJtaW5hbnQobSk7CglyZXR1cm4gbWF0M3gzPGYzMj4oCgkJdmVjMzxmMzI+KAoJCQkobVsxXVsxXSAqIG1bMl1bMl0gLSBtWzFdWzJdICogbVsyXVsxXSkgLyBkZXQsCgkJCShtWzBdWzJdICogbVsyXVsxXSAtIG1bMF1bMV0gKiBtWzJdWzJdKSAvIGRldCwKCQkJKG1bMF1bMV0gKiBtWzFdWzJdIC0gbVswXVsyXSAqIG1bMV1bMV0pIC8gZGV0CgkJKSwKCQl2ZWMzPGYzMj4oCgkJCShtWzFdWzJdICogbVsyXVswXSAtIG1bMV1bMF0gKiBtWzJdWzJdKSAvIGRldCwKCQkJKG1bMF1bMF0gKiBtWzJdWzJdIC0gbVswXVsyXSAqIG1bMl1bMF0pIC8gZGV0LAoJCQkobVswXVsyXSAqIG1bMV1bMF0gLSBtWzBdWzBdICogbVsxXVsyXSkgLyBkZXQKCQkpLAoJCXZlYzM8ZjMyPigKCQkJKG1bMV1bMF0gKiBtWzJdWzFdIC0gbVsxXVsxXSAqIG1bMl1bMF0pIC8gZGV0LAoJCQkobVswXVsxXSAqIG1bMl1bMF0gLSBtWzBdWzBdICogbVsyXVsxXSkgLyBkZXQsCgkJCShtWzBdWzBdICogbVsxXVsxXSAtIG1bMF1bMV0gKiBtWzFdWzBdKSAvIGRldAoJCSkKCSk7Cn0KCi8vaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL2EvMjMwNjAyOQpbW3N0YWdlKGNvbXB1dGUpLCB3b3JrZ3JvdXBfc2l6ZSgyNTYpXV0KZm4gbWFpbihbW2J1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpXV0gZ2xvYmFsIDogdmVjMzx1MzI+KSB7CglsZXQgaWQgPSBnbG9iYWwueDsKCWlmIChpZCA+PSBwYXJhbWV0ZXIubGVuZ3RoKSB7CgkJcmV0dXJuOwoJfQoJbGV0IHBvaW50ID0gY2xvdWQuZGF0YVtpZF07CglsZXQgb2Zmc2V0ID0gZ2xvYmFsLnggKiBwYXJhbWV0ZXIuazsKCXZhciBjb3VudCA9IDB1OwoJdmFyIGRpbSA9IHZlYzM8ZjMyPigwLjAsIDAuMCwgMC4wKTsKCWZvciAoOyBuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgY291bnRdICE9IGlkICYmIGNvdW50IDwgcGFyYW1ldGVyLms7IGNvdW50ID0gY291bnQgKyAxdSkgewoJCWRpbSA9IGRpbSArIGFicyhwb2ludCAtIGNsb3VkLmRhdGFbbmVhcmVzdC5kYXRhW29mZnNldCArIGNvdW50XSBdKTsKCX0KCgl2YXIgQXRBID0gbWF0M3gzPGYzMj4oCgkJdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApLAoJCXZlYzM8ZjMyPigwLjAsIDAuMCwgMC4wKSwKCQl2ZWMzPGYzMj4oMC4wLCAwLjAsIDAuMCkJCgkpOwoKCWlmIChkaW0ueiA8IGRpbS54ICYmIGRpbS56IDwgZGltLnkpIHsKCQlmb3IgKHZhciBpID0gMHU7IGkgPCBjb3VudDsgaSA9IGkgKyAxdSkgewoJCQlsZXQgcCA9IGNsb3VkLmRhdGFbbmVhcmVzdC5kYXRhW29mZnNldCArIGldIF07CgkJCUF0QVswXVswXSA9IEF0QVswXVswXSArICBwLnggKiBwLng7CgkJCUF0QVswXVsxXSA9IEF0QVswXVsxXSArICBwLnggKiBwLnk7CgkJCUF0QVswXVsyXSA9IEF0QVswXVsyXSArICBwLnggKiAxLjA7CgkJCUF0QVsxXVswXSA9IEF0QVsxXVswXSArICBwLnkgKiBwLng7CgkJCUF0QVsxXVsxXSA9IEF0QVsxXVsxXSArICBwLnkgKiBwLnk7CgkJCUF0QVsxXVsyXSA9IEF0QVsxXVsyXSArICBwLnkgKiAxLjA7CgkJCUF0QVsyXVswXSA9IEF0QVsyXVswXSArICAxLjAgKiBwLng7CgkJCUF0QVsyXVsxXSA9IEF0QVsyXVsxXSArICAxLjAgKiBwLnk7CgkJCUF0QVsyXVsyXSA9IEF0QVsyXVsyXSArICAxLjAgKiAxLjA7CgkJfQoJCQoJCWxldCBBdEExID0gaW52ZXJzZShBdEEpOwoKCQl2YXIgQXRCID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApOwoKCQlmb3IgKHZhciBpID0gMHU7IGkgPCBjb3VudDsgaSA9IGkgKyAxdSkgewoJCQlsZXQgcCA9IGNsb3VkLmRhdGFbbmVhcmVzdC5kYXRhW29mZnNldCArIGldIF07CgkJCUF0Qi54ID0gQXRCLnggKyBwLnggKiBwLno7CgkJCUF0Qi55ID0gQXRCLnkgKyBwLnkgKiBwLno7CgkJCUF0Qi56ID0gQXRCLnogKyAxLjAgKiBwLno7CgkJfQoKCQlsZXQgcGxhbmUgPSBBdEExICogQXRCOwoJCQoJCWNvbG9ycy5kYXRhW2lkXSA9IG5vcm1hbGl6ZShjcm9zcygKCQkJdmVjMzxmMzI+KDEuMCwgMC4wLCBwbGFuZS54KSwKCQkJdmVjMzxmMzI+KDAuMCwgMS4wLCBwbGFuZS55KSwKCQkpKTsKCX0gZWxzZWlmIChkaW0ueSA8IGRpbS54KSB7CgoJCWZvciAodmFyIGkgPSAwdTsgaSA8IGNvdW50OyBpID0gaSArIDF1KSB7CgkJCWxldCBwID0gY2xvdWQuZGF0YVtuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaV0gXTsKCQkJQXRBWzBdWzBdID0gQXRBWzBdWzBdICsgIHAueCAqIHAueDsKCQkJQXRBWzBdWzFdID0gQXRBWzBdWzFdICsgIHAueCAqIHAuejsKCQkJQXRBWzBdWzJdID0gQXRBWzBdWzJdICsgIHAueCAqIDEuMDsKCQkJQXRBWzFdWzBdID0gQXRBWzFdWzBdICsgIHAueiAqIHAueDsKCQkJQXRBWzFdWzFdID0gQXRBWzFdWzFdICsgIHAueiAqIHAuejsKCQkJQXRBWzFdWzJdID0gQXRBWzFdWzJdICsgIHAueiAqIDEuMDsKCQkJQXRBWzJdWzBdID0gQXRBWzJdWzBdICsgIDEuMCAqIHAueDsKCQkJQXRBWzJdWzFdID0gQXRBWzJdWzFdICsgIDEuMCAqIHAuejsKCQkJQXRBWzJdWzJdID0gQXRBWzJdWzJdICsgIDEuMCAqIDEuMDsKCQl9CgkJCgkJbGV0IEF0QTEgPSBpbnZlcnNlKEF0QSk7CgoJCXZhciBBdEIgPSB2ZWMzPGYzMj4oMC4wLCAwLjAsIDAuMCk7CgoJCWZvciAodmFyIGkgPSAwdTsgaSA8IGNvdW50OyBpID0gaSArIDF1KSB7CgkJCWxldCBwID0gY2xvdWQuZGF0YVtuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaV0gXTsKCQkJQXRCLnggPSBBdEIueCArIHAueCAqIHAueTsKCQkJQXRCLnkgPSBBdEIueSArIHAueiAqIHAueTsKCQkJQXRCLnogPSBBdEIueiArIDEuMCAqIHAueTsKCQl9CgoKCQkvLyBBKnggKyBCKnkgKyBDID0gegoJCWxldCBwbGFuZSA9IEF0QTEgKiBBdEI7CgkJCgkJY29sb3JzLmRhdGFbaWRdID0gbm9ybWFsaXplKGNyb3NzKAoJCQl2ZWMzPGYzMj4oMS4wLCBwbGFuZS54LCAwLjApLAoJCQl2ZWMzPGYzMj4oMC4wLCBwbGFuZS55LCAxLjApLAoJCSkpOwoJCgl9IGVsc2UgewoJCQoJCWZvciAodmFyIGkgPSAwdTsgaSA8IGNvdW50OyBpID0gaSArIDF1KSB7CgkJCWxldCBwID0gY2xvdWQuZGF0YVtuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaV0gXTsKCQkJQXRBWzBdWzBdID0gQXRBWzBdWzBdICsgIHAueSAqIHAueTsKCQkJQXRBWzBdWzFdID0gQXRBWzBdWzFdICsgIHAueSAqIHAuejsKCQkJQXRBWzBdWzJdID0gQXRBWzBdWzJdICsgIHAueSAqIDEuMDsKCQkJQXRBWzFdWzBdID0gQXRBWzFdWzBdICsgIHAueiAqIHAueTsKCQkJQXRBWzFdWzFdID0gQXRBWzFdWzFdICsgIHAueiAqIHAuejsKCQkJQXRBWzFdWzJdID0gQXRBWzFdWzJdICsgIHAueiAqIDEuMDsKCQkJQXRBWzJdWzBdID0gQXRBWzJdWzBdICsgIDEuMCAqIHAueTsKCQkJQXRBWzJdWzFdID0gQXRBWzJdWzFdICsgIDEuMCAqIHAuejsKCQkJQXRBWzJdWzJdID0gQXRBWzJdWzJdICsgIDEuMCAqIDEuMDsKCQl9CgkJCgkJbGV0IEF0QTEgPSBpbnZlcnNlKEF0QSk7CgoJCXZhciBBdEIgPSB2ZWMzPGYzMj4oMC4wLCAwLjAsIDAuMCk7CgoJCWZvciAodmFyIGkgPSAwdTsgaSA8IGNvdW50OyBpID0gaSArIDF1KSB7CgkJCWxldCBwID0gY2xvdWQuZGF0YVtuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaV0gXTsKCQkJQXRCLnggPSBBdEIueCArIHAueSAqIHAueDsKCQkJQXRCLnkgPSBBdEIueSArIHAueiAqIHAueDsKCQkJQXRCLnogPSBBdEIueiArIDEuMCAqIHAueDsKCQl9CgoJCWxldCBwbGFuZSA9IEF0QTEgKiBBdEI7CgkJCgkJY29sb3JzLmRhdGFbaWRdID0gbm9ybWFsaXplKGNyb3NzKAoJCQl2ZWMzPGYzMj4ocGxhbmUueCwgMS4wLCAwLjApLAoJCQl2ZWMzPGYzMj4ocGxhbmUueSwgMC4wLCAxLjApLAoJCSkpOwoJfQp9Cg==";

	var normalTriangURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gbmVhcmVzdDogSW5kaWNlczsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCB3cml0ZT4gY29sb3JzOiBCdWZmZXI7CgpsZXQgUEkgPSAzLjE0MTU5MjY1Mzg7CgpbW3N0YWdlKGNvbXB1dGUpLCB3b3JrZ3JvdXBfc2l6ZSgyNTYpXV0KZm4gbWFpbihbW2J1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpXV0gZ2xvYmFsIDogdmVjMzx1MzI+KSB7CglsZXQgaWQgPSBnbG9iYWwueDsKCWlmIChpZCA+PSBwYXJhbWV0ZXIubGVuZ3RoKSB7CgkJcmV0dXJuOwoJfQoJbGV0IG9mZnNldCA9IGdsb2JhbC54ICogcGFyYW1ldGVyLms7CglsZXQgcCA9IGNsb3VkLmRhdGFbaWRdOwoJdmFyIGxhc3QgPSBjbG91ZC5kYXRhW25lYXJlc3QuZGF0YVtvZmZzZXRdIF07Cgl2YXIgbiA9IHZlYzM8ZjMyPigwLjAsIDAuMCwgMC4wKTsKCXZhciBjb3VudCA9IDF1OwoJZm9yICgKCQk7CgkJbmVhcmVzdC5kYXRhW29mZnNldCArIGNvdW50XSAhPSBpZCAmJiBjb3VudCA8IHBhcmFtZXRlci5rOwoJCWNvdW50ID0gY291bnQgKyAxdQoJKSB7CgkJbGV0IGN1cnJlbnQgPSBjbG91ZC5kYXRhW25lYXJlc3QuZGF0YVtvZmZzZXQgKyBjb3VudF0gXTsKCQluID0gbiArIGNyb3NzKGxhc3QgLSBwLCBjdXJyZW50IC0gcCk7CgkJbGFzdCA9IGN1cnJlbnQ7Cgl9CgoJY29sb3JzLmRhdGFbaWRdID0gIG5vcm1hbGl6ZShuKTsKfQo=";

	var curvaturePointsURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gbmVhcmVzdDogSW5kaWNlczsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBub3JtYWxzOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoNCldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IGNvbG9yczogQnVmZmVyOwoKbGV0IFBJID0gMy4xNDE1OTI2NTM4OwoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCWxldCBvZmZzZXQgPSBpZCAqIHBhcmFtZXRlci5rOwoJbGV0IHAgPSBjbG91ZC5kYXRhW2lkXTsKCWxldCBuID0gbm9ybWFscy5kYXRhW2lkXTsKCXZhciBvZmYgPSAwLjA7Cgl2YXIgaSA9IDB1OwoJZm9yICg7IGkgPCBwYXJhbWV0ZXIuazsgaSA9IGkgKyAxdSkgewoJCWxldCBpZHggPSBuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaV07CgkJaWYgKGlkeCA9PSBpZCkgewoJCQlicmVhazsKCQl9CgkJb2ZmID0gb2ZmICsgYWJzKGRvdChub3JtYWxpemUocCAtIGNsb3VkLmRhdGFbaWR4XSksIG5vcm1hbGl6ZShuKSkpOwoJfSAKCW9mZiA9IG9mZiAvIGYzMihpKTsKCWNvbG9ycy5kYXRhW2lkXSA9IHZlYzM8ZjMyPihvZmYsIDAuMCwgMC4wKTsKfQo=";

	var curvatureNormalURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gbmVhcmVzdDogSW5kaWNlczsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBub3JtYWxzOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoNCldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IGNvbG9yczogQnVmZmVyOwoKbGV0IFBJID0gMy4xNDE1OTI2NTM4OwoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCWxldCBvZmZzZXQgPSBpZCAqIHBhcmFtZXRlci5rOwoJbGV0IHAgPSBjbG91ZC5kYXRhW2lkXTsKCWxldCBuID0gbm9ybWFscy5kYXRhW2lkXTsKCXZhciBvZmYgPSAwLjA7Cgl2YXIgaSA9IDB1OwoJZm9yICg7IGkgPCBwYXJhbWV0ZXIuazsgaSA9IGkgKyAxdSkgewoJCWxldCBpZHggPSBuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaV07CgkJaWYgKGlkeCA9PSBpZCkgewoJCQlicmVhazsKCQl9CgkJb2ZmID0gb2ZmICsgYWJzKGRvdChub3JtYWxpemUobm9ybWFscy5kYXRhW2lkeF0pLCBub3JtYWxpemUobikpKTsKCX0gCglvZmYgPSAxLjAgLSBvZmYgLyBmMzIoaSk7Cgljb2xvcnMuZGF0YVtpZF0gPSB2ZWMzPGYzMj4ob2ZmLCAwLjAsIDAuMCk7Cn0K";

	var triangulateAllURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7Cn07CgpsZXQgTUFYX0sgPSAxNnU7CmxldCBNQVhfRElTVEFOQ0UgPSAzNDAyODIzNDY2Mzg1Mjg4NTk4MTE3MDQxODM0ODQ1MTY5MjU0NDAuMDsgLy9tYXggdmFsdWUgZm9yIGYzMiAoaSB0aGluaykKbGV0IFBJID0gMy4xNDE1OTI2NTM4OwoKCltbZ3JvdXAoMCksIGJpbmRpbmcoMCldXSB2YXI8c3RvcmFnZSwgcmVhZD4gcGFyYW1ldGVyOiBQYXJhbWV0ZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMSldXSB2YXI8c3RvcmFnZSwgcmVhZD4gY2xvdWQ6IEJ1ZmZlcjsKW1tncm91cCgwKSwgYmluZGluZygyKV1dIHZhcjxzdG9yYWdlLCB3cml0ZT4gbmVhcmVzdDogSW5kaWNlczsKCltbc3RhZ2UoY29tcHV0ZSksIHdvcmtncm91cF9zaXplKDI1NildXQpmbiBtYWluKFtbYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCldXSBnbG9iYWwgOiB2ZWMzPHUzMj4pIHsKCWxldCBpZCA9IGdsb2JhbC54OwoJaWYgKGlkID49IHBhcmFtZXRlci5sZW5ndGgpIHsKCQlyZXR1cm47Cgl9CgkvL2dldCBuZWFyZXN0CglsZXQgcCA9IGNsb3VkLmRhdGFbaWRdOwoJdmFyIGRpc3QgPSBNQVhfRElTVEFOQ0U7Cgl2YXIgbmVhcjogdTMyOwoJZm9yICh2YXIgaSA9IDB1OyBpIDwgcGFyYW1ldGVyLmxlbmd0aDsgaSA9IGkgKyAxdSkgewoJCWlmIChpICE9IGlkKSB7CgkJCWxldCBkID0gZGlzdGFuY2UocCwgY2xvdWQuZGF0YVtpXSk7CgkJCWlmIChkIDwgZGlzdCkgewoJCQkJZGlzdCA9IGQ7CgkJCQluZWFyID0gaTsKCQkJfQoJCX0KCX0KCglsZXQgb2Zmc2V0ID0gaWQgKiBNQVhfSzsKCW5lYXJlc3QuZGF0YVtvZmZzZXRdID0gbmVhcjsKCQoJdmFyIGN1cnJlbnQgPSBuZWFyOwoJdmFyIGlkeCA9IDF1OwoJdmFyIGRpcmVjdGlvbiA9IHZlYzM8ZjMyPigwLjAsIDAuMCwgMC4wKTsKCXZhciBjdXJyZW50X3BvaW50ID0gY2xvdWQuZGF0YVtjdXJyZW50XTsKCWZvciAoOyBpZHggPCBNQVhfSzsgaWR4ID0gaWR4ICsgMXUpIHsKCQl2YXIgbmV4dCA9IHBhcmFtZXRlci5sZW5ndGg7CgkJdmFyIGJlc3QgPSAwLjA7CgoJCWZvciAodmFyIGkgPSAwdTsgaSA8IHBhcmFtZXRlci5sZW5ndGg7IGkgPSBpICsgMXUpIHsKCQkJaWYgKGkgPT0gaWQgfHwgaSA9PSBjdXJyZW50KSB7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvL2NoZWNrIGlmIHRoaXMgcG9pbnQgaXMgZnVydGhlciBpbiB0aGUgcm90YXRpb24KCQkJbGV0IG5fcG9pbnQgPSBjbG91ZC5kYXRhW2ldOwoJCQlpZiAoZG90KHAgLSBuX3BvaW50LCBkaXJlY3Rpb24pID4gMC4wKSB7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhd19vZl9zaW5lcwoJCQlsZXQgYWIgPSBub3JtYWxpemUocCAtIG5fcG9pbnQpOwoJCQlsZXQgYWMgPSBub3JtYWxpemUoY3VycmVudF9wb2ludCAtIG5fcG9pbnQpOwoJCQlsZXQgYWxwaGEgPSBhY29zKGRvdChhYiwgYWMpKTsKCQkJaWYgKGFscGhhID4gYmVzdCkgeyAvL2dldCAibmVhcmVzdCIgcG9pbnQgd2l0aCBiaWdnZXN0IGFscGhhCgkJCQluZXh0ID0gaTsKCQkJCWJlc3QgPSBhbHBoYTsKCQkJfQoJCX0KCgkJaWYgKG5leHQgPT0gbmVhcikgeyAvL2Z1bGwgY2lyY2xlCgkJCWJyZWFrOwoJCX0KCQlsZXQgbl9wb2ludCA9IGNsb3VkLmRhdGFbbmV4dF07CgkJaWYgKG5leHQgPT0gcGFyYW1ldGVyLmxlbmd0aCkgeyAvL25vdCBhIHZhbGlkIG5leHQgYXZhaWJsZSAocmVjb3Zlcj8pCgkJCWZvciAodmFyIGkgPSAwdTsgaSA8IGlkeDsgaSA9IGkgKyAxdSkgewoJCQkJbmVhcmVzdC5kYXRhW29mZnNldCArIGldID0gaWQ7CgkJCX0KCQkJYnJlYWs7CgkJfQoJCWRpcmVjdGlvbiA9IGNyb3NzKGNyb3NzKGN1cnJlbnRfcG9pbnQgLSBwLCBuX3BvaW50IC0gcCksIG5fcG9pbnQgLSBwKTsKCQljdXJyZW50X3BvaW50ID0gbl9wb2ludDsKCQluZWFyZXN0LmRhdGFbb2Zmc2V0ICsgaWR4XSA9IG5leHQ7CgkJY3VycmVudCA9IG5leHQ7Cgl9Cglmb3IgKDsgaWR4IDwgTUFYX0s7IGlkeCA9IGlkeCArIDF1KSB7CgkJbmVhcmVzdC5kYXRhW29mZnNldCArIGlkeF0gPSBpZDsKCX0KfQo=";

	var triangulateNearestURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7Cn07CgpsZXQgTUFYX0sgPSAxNnU7CmxldCBNQVhfRElTVEFOQ0UgPSAzNDAyODIzNDY2Mzg1Mjg4NTk4MTE3MDQxODM0ODQ1MTY5MjU0NDAuMDsgLy9tYXggdmFsdWUgZm9yIGYzMiAoaSB0aGluaykKbGV0IFBJID0gMy4xNDE1OTI2NTM4OwoKW1tncm91cCgwKSwgYmluZGluZygwKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBwYXJhbWV0ZXI6IFBhcmFtZXRlcjsKW1tncm91cCgwKSwgYmluZGluZygxKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBjbG91ZDogQnVmZmVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDIpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IG5lYXJlc3Q6IEluZGljZXM7CltbZ3JvdXAoMCksIGJpbmRpbmcoMyldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IHRyaWFuZ2xlOiBJbmRpY2VzOwoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCWxldCBwID0gY2xvdWQuZGF0YVtpZF07CglsZXQgb2Zmc2V0ID0gaWQgKiBwYXJhbWV0ZXIuazsKCWxldCB3cml0ZV9vZmZzZXQgPSBpZCAqIE1BWF9LOwoJdmFyIG5lYXIgPSBuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgcGFyYW1ldGVyLmsgLSAxdV07CgoJdHJpYW5nbGUuZGF0YVt3cml0ZV9vZmZzZXRdID0gbmVhcjsKCXZhciBpZHggPSAxdTsKCgl2YXIgY3VycmVudCA9IG5lYXI7Cgl2YXIgZGlyZWN0aW9uID0gdmVjMzxmMzI+KDAuMCwgMC4wLCAwLjApOwoJdmFyIGN1cnJlbnRfcG9pbnQgPSBjbG91ZC5kYXRhW2N1cnJlbnRdOwoJZm9yICg7IGlkeCA8IE1BWF9LOyBpZHggPSBpZHggKyAxdSkgewoJCXZhciBuZXh0ID0gcGFyYW1ldGVyLmxlbmd0aDsKCQl2YXIgYmVzdCA9IDAuMDsKCgkJZm9yICh2YXIgdCA9IDB1OyB0IDwgcGFyYW1ldGVyLms7IHQgPSB0ICsgMXUpIHsKCQkJbGV0IGkgPSBuZWFyZXN0LmRhdGFbb2Zmc2V0ICsgdF07CgkJCWlmICggaSA9PSBjdXJyZW50KSB7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvL2NoZWNrIGlmIHRoaXMgcG9pbnQgaXMgZnVydGhlciBpbiB0aGUgcm90YXRpb24KCQkJbGV0IG5fcG9pbnQgPSBjbG91ZC5kYXRhW2ldOwoJCQlpZiAoZG90KHAgLSBuX3BvaW50LCBkaXJlY3Rpb24pID4gMC4wKSB7CgkJCQljb250aW51ZTsKCQkJfQoJCQkvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhd19vZl9zaW5lcwoJCQlsZXQgYWIgPSBub3JtYWxpemUocCAtIG5fcG9pbnQpOwoJCQlsZXQgYWMgPSBub3JtYWxpemUoY3VycmVudF9wb2ludCAtIG5fcG9pbnQpOwoJCQlsZXQgYWxwaGEgPSBhY29zKGRvdChhYiwgYWMpKTsKCQkJaWYgKGFscGhhID4gYmVzdCkgeyAvL2dldCAibmVhcmVzdCIgcG9pbnQgd2l0aCBiaWdnZXN0IGFscGhhCgkJCQluZXh0ID0gaTsKCQkJCWJlc3QgPSBhbHBoYTsKCQkJfQoJCX0KCgkJaWYgKG5leHQgPT0gbmVhcikgeyAvL2Z1bGwgY2lyY2xlCgkJCWJyZWFrOwoJCX0KCQlsZXQgbl9wb2ludCA9IGNsb3VkLmRhdGFbbmV4dF07CgkJaWYgKG5leHQgPT0gcGFyYW1ldGVyLmxlbmd0aCkgeyAvL25vdCBhIHZhbGlkIG5leHQgYXZhaWJsZSAocmVjb3Zlcj8pCgkJCWZvciAodmFyIGkgPSAwdTsgaSA8IGlkeDsgaSA9IGkgKyAxdSkgewoJCQkJdHJpYW5nbGUuZGF0YVt3cml0ZV9vZmZzZXQgKyBpXSA9IGlkOwoJCQl9CgkJCWJyZWFrOwoJCX0KCQlkaXJlY3Rpb24gPSBjcm9zcyhjcm9zcyhjdXJyZW50X3BvaW50IC0gcCwgbl9wb2ludCAtIHApLCBuX3BvaW50IC0gcCk7CgkJY3VycmVudF9wb2ludCA9IG5fcG9pbnQ7CgkJdHJpYW5nbGUuZGF0YVt3cml0ZV9vZmZzZXQgKyBpZHhdID0gbmV4dDsKCQljdXJyZW50ID0gbmV4dDsKCX0KCWZvciAoOyBpZHggPCBNQVhfSzsgaWR4ID0gaWR4ICsgMXUpIHsKCQl0cmlhbmdsZS5kYXRhW3dyaXRlX29mZnNldCArIGlkeF0gPSBpZDsKCX0KfQo=";

	var reduceLowURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CgluZXdfbGVuZ3RoOiB1MzI7Cgl0aHJlc2hob2xkOiBmMzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gY29sb3I6IEJ1ZmZlcjsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBkaXN0YW5jZXM6IEJ1ZmZlcjsKW1tncm91cCgwKSwgYmluZGluZyg0KV1dIHZhcjxzdG9yYWdlLCB3cml0ZT4gY2xvdWRfZmlsdGVyOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoNSldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IGNvbG9yX2ZpbHRlcjogQnVmZmVyOwoKbGV0IE1BWF9ESVNUQU5DRSA9IDM0MDI4MjM0NjYzODUyODg1OTgxMTcwNDE4MzQ4NDUxNjkyNTQ0MC4wOyAvL21heCB2YWx1ZSBmb3IgZjMyIChpIHRoaW5rKQoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCglpZiAoYWJzKGRpc3RhbmNlcy5kYXRhW2lkXS54KSA8IHBhcmFtZXRlci50aHJlc2hob2xkKSB7CgkJcmV0dXJuOwoJfQoJdmFyIGlkeCA9IDB1OwoJZm9yICh2YXIgaSA9IDB1OyBpIDwgaWQ7IGkgPSBpICsgMXUpIHsKCQlpZiAoYWJzKGRpc3RhbmNlcy5kYXRhW2ldLngpID49IHBhcmFtZXRlci50aHJlc2hob2xkKSB7CgkJCWlkeCA9IGlkeCArIDF1OwoJCX0KCX0KCWNsb3VkX2ZpbHRlci5kYXRhW2lkeF0gPSBjbG91ZC5kYXRhW2lkXTsKCWNvbG9yX2ZpbHRlci5kYXRhW2lkeF0gPSBjb2xvci5kYXRhW2lkXTsKCglmb3IgKHZhciBpID0gaWQgKyAxdTsgaSA8IHBhcmFtZXRlci5sZW5ndGg7IGkgPSBpICsgMXUpIHsKCQlpZiAoYWJzKGRpc3RhbmNlcy5kYXRhW2ldLngpID49IHBhcmFtZXRlci50aHJlc2hob2xkKSB7CgkJCXJldHVybjsKCQl9Cgl9CglwYXJhbWV0ZXIubmV3X2xlbmd0aCA9IGlkeDsKfQo=";

	var reduceAnomalyURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CgluZXdfbGVuZ3RoOiB1MzI7Cgl0aHJlc2hob2xkOiBmMzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gY29sb3I6IEJ1ZmZlcjsKW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBkaXN0YW5jZXM6IEJ1ZmZlcjsKW1tncm91cCgwKSwgYmluZGluZyg0KV1dIHZhcjxzdG9yYWdlLCB3cml0ZT4gY2xvdWRfZmlsdGVyOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoNSldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IGNvbG9yX2ZpbHRlcjogQnVmZmVyOwoKbGV0IE1BWF9ESVNUQU5DRSA9IDM0MDI4MjM0NjYzODUyODg1OTgxMTcwNDE4MzQ4NDUxNjkyNTQ0MC4wOyAvL21heCB2YWx1ZSBmb3IgZjMyIChpIHRoaW5rKQoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCglpZiAoYWJzKGRpc3RhbmNlcy5kYXRhW2lkXS54KSA+PSBwYXJhbWV0ZXIudGhyZXNoaG9sZCkgewoJCXJldHVybjsKCX0KCXZhciBpZHggPSAwdTsKCWZvciAodmFyIGkgPSAwdTsgaSA8IGlkOyBpID0gaSArIDF1KSB7CgkJaWYgKGFicyhkaXN0YW5jZXMuZGF0YVtpXS54KSA8IHBhcmFtZXRlci50aHJlc2hob2xkKSB7CgkJCWlkeCA9IGlkeCArIDF1OwoJCX0KCX0KCWNsb3VkX2ZpbHRlci5kYXRhW2lkeF0gPSBjbG91ZC5kYXRhW2lkXTsKCWNvbG9yX2ZpbHRlci5kYXRhW2lkeF0gPSBjb2xvci5kYXRhW2lkXTsKCglmb3IgKHZhciBpID0gaWQgKyAxdTsgaSA8IHBhcmFtZXRlci5sZW5ndGg7IGkgPSBpICsgMXUpIHsKCQlpZiAoYWJzKGRpc3RhbmNlcy5kYXRhW2ldLngpIDwgcGFyYW1ldGVyLnRocmVzaGhvbGQpIHsKCQkJcmV0dXJuOwoJCX0KCX0KCXBhcmFtZXRlci5uZXdfbGVuZ3RoID0gaWR4Owp9Cg==";

	var sortURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7Cn07CgpbW2dyb3VwKDApLCBiaW5kaW5nKDApXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBhcmFtZXRlcjogUGFyYW1ldGVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDEpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IGNsb3VkOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gY29sb3JzOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMyldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IGNsb3VkX3NvcnRlZDogQnVmZmVyOwpbW2dyb3VwKDApLCBiaW5kaW5nKDQpXV0gdmFyPHN0b3JhZ2UsIHdyaXRlPiBjb2xvcnNfc29ydGVkOiBCdWZmZXI7CgoKW1tzdGFnZShjb21wdXRlKSwgd29ya2dyb3VwX3NpemUoMjU2KV1dCmZuIG1haW4oW1tidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKV1dIGdsb2JhbCA6IHZlYzM8dTMyPikgewoJbGV0IGlkID0gZ2xvYmFsLng7CglpZiAoaWQgPj0gcGFyYW1ldGVyLmxlbmd0aCkgewoJCXJldHVybjsKCX0KCXZhciBwID0gY2xvdWQuZGF0YVtpZF07Cgl2YXIgaWR4ID0gMHU7CgoJZm9yICh2YXIgaSA9IDB1OyBpIDwgcGFyYW1ldGVyLmxlbmd0aDsgaSA9IGkgKyAxdSkgewoJCWxldCBvdGhlciA9IGNsb3VkLmRhdGFbaV07CgkJaWYgKG90aGVyLnggPCBwLnggfHwgKG90aGVyLnggPT0gcC54ICYmIGkgPCBpZCkpIHsKCQkJaWR4ID0gaWR4ICsgMXU7CgkJfQoJfQoJY2xvdWRfc29ydGVkLmRhdGFbaWR4XSA9IHA7Cgljb2xvcnNfc29ydGVkLmRhdGFbaWR4XSA9IGNvbG9ycy5kYXRhW2lkXTsKfQo=";

	var noiseURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBCdWZmZXIgewoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7CglkYXRhOiBhcnJheTx1MzI+Owp9OwoKW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgewoJbGVuZ3RoOiB1MzI7CglrOiB1MzI7CglhbW91bnQgOmYzMjsKfTsKCltbZ3JvdXAoMCksIGJpbmRpbmcoMCldXSB2YXI8c3RvcmFnZSwgcmVhZD4gcGFyYW1ldGVyOiBQYXJhbWV0ZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMSldXSB2YXI8c3RvcmFnZSwgcmVhZD4gY2xvdWQ6IEJ1ZmZlcjsKW1tncm91cCgwKSwgYmluZGluZygyKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBub3JtYWxzOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMyldXSB2YXI8c3RvcmFnZSwgcmVhZD4gZGlzdGFuY2VzOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoNCldXSB2YXI8c3RvcmFnZSwgd3JpdGU+IG5ld19jbG91ZDogQnVmZmVyOwoKCltbc3RhZ2UoY29tcHV0ZSksIHdvcmtncm91cF9zaXplKDI1NildXQpmbiBtYWluKFtbYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCldXSBnbG9iYWwgOiB2ZWMzPHUzMj4pIHsKCWxldCBpZCA9IGdsb2JhbC54OwoJaWYgKGlkID49IHBhcmFtZXRlci5sZW5ndGgpIHsKCQlyZXR1cm47Cgl9CglsZXQgcG9pbnQgPSBjbG91ZC5kYXRhW2lkXTsKCW5ld19jbG91ZC5kYXRhW2lkXSA9IGNsb3VkLmRhdGFbaWRdIC0gZGlzdGFuY2VzLmRhdGFbaWRdLnggKiBwYXJhbWV0ZXIuYW1vdW50ICogbm9ybWFscy5kYXRhW2lkXTsKfQo=";

	let pipelines = {
	    cleanDang: undefined,
	    cleanLong: undefined,
	    kNearestList: undefined,
	    kNearestIter: undefined,
	    kNearestIterSorted: undefined,
	    kNearestListSorted: undefined,
	    normalLinear: undefined,
	    normalTriang: undefined,
	    curvaturePoints: undefined,
	    curvatureNormal: undefined,
	    triangulateAll: undefined,
	    triangulateNearest: undefined,
	    reduceLow: undefined,
	    reduceAnomaly: undefined,
	    sort: undefined,
	    noise: undefined,
	};
	function Setup$1() {
	    const helper = (uri) => {
	        return device.createComputePipeline({
	            compute: {
	                module: NewModule(ConvertURI(uri)),
	                entryPoint: 'main',
	            },
	        });
	    };
	    pipelines = {
	        cleanDang: helper(cleanDangURI),
	        cleanLong: helper(cleanLongURI),
	        kNearestList: helper(kNearestListURI),
	        kNearestIter: helper(kNearestIterURI),
	        kNearestIterSorted: helper(kNearestIterSortedURI),
	        kNearestListSorted: helper(kNearestListSortedURI),
	        normalLinear: helper(normalLinearURI),
	        normalTriang: helper(normalTriangURI),
	        curvaturePoints: helper(curvaturePointsURI),
	        curvatureNormal: helper(curvatureNormalURI),
	        triangulateAll: helper(triangulateAllURI),
	        triangulateNearest: helper(triangulateNearestURI),
	        reduceLow: helper(reduceLowURI),
	        reduceAnomaly: helper(reduceAnomalyURI),
	        sort: helper(sortURI),
	        noise: helper(noiseURI),
	    };
	}
	function Compute(name, length, parameter, buffers, result = false) {
	    const paramU32 = new Uint32Array(1 + parameter[0].length + parameter[1].length);
	    const paramF32 = new Float32Array(paramU32.buffer);
	    paramU32[0] = length;
	    for (let i = 0; i < parameter[0].length; i++) {
	        paramU32[i + 1] = parameter[0][i];
	    }
	    for (let i = 0; i < parameter[1].length; i++) {
	        paramF32[parameter[0].length + i + 1] = parameter[1][i];
	    }
	    const buffer = CreateBuffer(paramU32, GPUBufferUsage.STORAGE);
	    const x = [];
	    x.push({
	        binding: 0,
	        resource: { buffer: buffer },
	    });
	    for (let i = 0; i < buffers.length; i++) {
	        x.push({
	            binding: i + 1,
	            resource: { buffer: buffers[i] }
	        });
	    }
	    const pipeline = pipelines[name];
	    const group = device.createBindGroup({
	        layout: pipeline.getBindGroupLayout(0),
	        entries: x,
	    });
	    const encoder = device.createCommandEncoder();
	    const compute = encoder.beginComputePass({});
	    compute.setPipeline(pipeline);
	    compute.setBindGroup(0, group);
	    compute.dispatch(Math.ceil(length / 256));
	    compute.endPass();
	    const commands = encoder.finish();
	    device.queue.submit([commands]);
	    if (result) {
	        return buffer;
	    }
	    else {
	        buffer.destroy();
	        return undefined;
	    }
	}

	class Matrix {
	    data;
	    constructor(data) {
	        this.data = data;
	    }
	    static Identity() {
	        return new Matrix(new Float32Array([
	            1, 0, 0, 0,
	            0, 1, 0, 0,
	            0, 0, 1, 0,
	            0, 0, 0, 1,
	        ]));
	    }
	    Save(location, offset) {
	        for (let i = 0; i < 4; i++) {
	            for (let j = 0; j < 4; j++) {
	                location[offset + i * 4 + j] = this.data[i + j * 4];
	            }
	        }
	    }
	    static Translate(x, y, z) {
	        return new Matrix(new Float32Array([
	            1, 0, 0, x,
	            0, 1, 0, y,
	            0, 0, 1, z,
	            0, 0, 0, 1
	        ]));
	    }
	    static RotateX(rad) {
	        return new Matrix(new Float32Array([
	            1, 0, 0, 0,
	            0, Math.cos(rad), -Math.sin(rad), 0,
	            0, Math.sin(rad), Math.cos(rad), 0,
	            0, 0, 0, 1,
	        ]));
	    }
	    static Rotate(rad, axis) {
	        const sin = Math.sin(rad);
	        const cos = Math.cos(rad);
	        const cosN = 1 - cos;
	        return new Matrix(new Float32Array([
	            axis.x * axis.x * cosN + cos,
	            axis.x * axis.y * cosN - axis.z * sin,
	            axis.x * axis.z * cosN + axis.y * sin,
	            0,
	            axis.y * axis.x * cosN + axis.z * sin,
	            axis.y * axis.y * cosN + cos,
	            axis.y * axis.z * cosN - axis.x * sin,
	            0,
	            axis.z * axis.x * cosN - axis.y * sin,
	            axis.z * axis.y * cosN + axis.x * sin,
	            axis.z * axis.z * cosN + cos,
	            0,
	            0, 0, 0, 1,
	        ]));
	    }
	    static RotateY(rad) {
	        return new Matrix(new Float32Array([
	            Math.cos(rad), 0, Math.sin(rad), 0,
	            0, 1, 0, 0,
	            -Math.sin(rad), 0, Math.cos(rad), 0,
	            0, 0, 0, 1,
	        ]));
	    }
	    static RotateZ(rad) {
	        return new Matrix(new Float32Array([
	            Math.cos(rad), -Math.sin(rad), 0, 0,
	            Math.sin(rad), Math.cos(rad), 0, 0,
	            0, 0, 1, 0,
	            0, 0, 0, 1,
	        ]));
	    }
	    static Scale(x, y, z) {
	        return new Matrix(new Float32Array([
	            x, 0, 0, 0,
	            0, y, 0, 0,
	            0, 0, z, 0,
	            0, 0, 0, 1,
	        ]));
	    }
	    Multiply(m) {
	        const res = new Float32Array(16);
	        for (let i = 0; i < 4; i++) {
	            for (let j = 0; j < 4; j++) {
	                for (let c = 0; c < 4; c++) {
	                    res[i + j * 4] += this.data[c + j * 4] * m.data[i + c * 4];
	                }
	            }
	        }
	        return new Matrix(res);
	    }
	    MultiplyVector(v) {
	        return {
	            x: this.data[0] * v.x + this.data[1] * v.y + this.data[2] * v.z,
	            y: this.data[4] * v.x + this.data[5] * v.y + this.data[6] * v.z,
	            z: this.data[8] * v.x + this.data[9] * v.y + this.data[10] * v.z,
	        };
	    }
	    Position() {
	        return {
	            x: this.data[3],
	            y: this.data[7],
	            z: this.data[11],
	        };
	    }
	    static Perspective(fovy, aspect, near, far) {
	        const c2 = (far + near) / (near - far);
	        const c1 = (2 * far * near) / (near - far);
	        const s = 1 / Math.tan(fovy / 2);
	        const m = new Float32Array([
	            s / aspect, 0, 0, 0,
	            0, s, 0, 0,
	            0, 0, c2, c1,
	            0, 0, -1, 0,
	        ]);
	        return new Matrix(m);
	    }
	}

	class Position {
	    model;
	    constructor() {
	        this.model = Matrix.Identity();
	    }
	    Save(location, offset) {
	        this.model.Save(location, offset);
	    }
	    Translate(x, y, z) {
	        this.model = Matrix.Translate(x, y, z).Multiply(this.model);
	    }
	    RotateX(rad) {
	        this.model = Matrix.RotateX(rad).Multiply(this.model);
	    }
	    RotateXLocal(rad) {
	        const p = this.model.Position();
	        this.model = Matrix.Translate(p.x, p.y, p.z)
	            .Multiply(Matrix.RotateX(rad))
	            .Multiply(Matrix.Translate(-p.x, -p.y, -p.z))
	            .Multiply(this.model);
	    }
	    RotateY(rad) {
	        this.model = Matrix.RotateY(rad).Multiply(this.model);
	    }
	    RotateYLocal(rad) {
	        const p = this.model.Position();
	        this.model = Matrix.Translate(p.x, p.y, p.z)
	            .Multiply(Matrix.RotateY(rad))
	            .Multiply(Matrix.Translate(-p.x, -p.y, -p.z))
	            .Multiply(this.model);
	    }
	    RotateZ(rad) {
	        this.model = Matrix.RotateZ(rad).Multiply(this.model);
	    }
	    RotateZLocal(rad) {
	        const p = this.model.Position();
	        this.model = Matrix.Translate(p.x, p.y, p.z)
	            .Multiply(Matrix.RotateZ(rad))
	            .Multiply(Matrix.Translate(-p.x, -p.y, -p.z))
	            .Multiply(this.model);
	    }
	    Scale(x, y, z) {
	        this.model = Matrix.Scale(x, y, z).Multiply(this.model);
	    }
	}

	class Camera {
	    projection;
	    view;
	    fov;
	    constructor(fieldOfView) {
	        this.projection = Matrix.Perspective(fieldOfView, aspect(), 0.1, 1000);
	        this.view = Matrix.Identity();
	        this.fov = fieldOfView;
	    }
	    set fieldOfView(val) {
	        this.fov = val;
	        this.projection = Matrix.Perspective(val, aspect(), 0.1, 100);
	    }
	    get fieldOfView() {
	        return this.fov;
	    }
	    Buffer() {
	        const array = new Float32Array(16 * 2);
	        this.projection.Save(array, 0);
	        this.view.Save(array, 16);
	        return CreateBuffer(array, GPUBufferUsage.UNIFORM);
	    }
	    UpdateSize() {
	        this.projection = Matrix.Perspective(this.fov, aspect(), 1, 1000);
	    }
	    Translate(x, y, z) {
	        this.view = Matrix.Translate(-x, -y, -z).Multiply(this.view);
	    }
	    RotateX(rad) {
	        this.view = Matrix.RotateX(-rad).Multiply(this.view);
	    }
	    RotateY(rad) {
	        this.view = Matrix.RotateY(-rad).Multiply(this.view);
	    }
	    RotateGlobalY(rad) {
	        const axis = this.view.MultiplyVector({ x: 0, y: 1, z: 0 });
	        this.view = Matrix.Rotate(-rad, axis).Multiply(this.view);
	    }
	    RotateZ(rad) {
	        this.view = Matrix.RotateZ(-rad).Multiply(this.view);
	    }
	}

	var srcURI$3 = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBDYW1lcmEgew0KCXByb2plY3Rpb246IG1hdDR4NDxmMzI+Ow0KCXZpZXc6IG1hdDR4NDxmMzI+Ow0KfTsNCg0KDQpbW2Jsb2NrXV0gc3RydWN0IFBhcmFtZXRlciB7DQoJbW9kZWw6IG1hdDR4NDxmMzI+Ow0KfTsNCg0KW1tncm91cCgwKSwgYmluZGluZygwKV1dIHZhcjx1bmlmb3JtPiBjYW1lcmE6IENhbWVyYTsNCltbZ3JvdXAoMCksIGJpbmRpbmcoMSldXSB2YXI8dW5pZm9ybT4gcGFyYW1ldGVyOiBQYXJhbWV0ZXI7DQoNCnN0cnVjdCBUcmFuc2ZlciB7DQoJW1tidWlsdGluKHBvc2l0aW9uKV1dIHBvc2l0aW9uIDogdmVjNDxmMzI+Ow0KCVtbbG9jYXRpb24oMCldXSBjb2xvcjogdmVjMzxmMzI+Ow0KfTsNCg0KW1tzdGFnZSh2ZXJ0ZXgpXV0NCmZuIHZlcnRleE1haW4oDQoJW1tsb2NhdGlvbigwKV1dIHZlcnRleDogdmVjMzxmMzI+LA0KCVtbbG9jYXRpb24oMSldXSBjb2xvcjogdmVjMzxmMzI+LA0KKSAtPiBUcmFuc2ZlciB7DQoJdmFyIG91dHB1dCA6IFRyYW5zZmVyOw0KCW91dHB1dC5wb3NpdGlvbiA9IGNhbWVyYS5wcm9qZWN0aW9uICogY2FtZXJhLnZpZXcgKiBwYXJhbWV0ZXIubW9kZWwgKiB2ZWM0PGYzMj4odmVydGV4LCAxLjApOw0KCW91dHB1dC5jb2xvciA9IGNvbG9yOw0KCXJldHVybiBvdXRwdXQ7DQp9DQoNCltbc3RhZ2UoZnJhZ21lbnQpXV0NCmZuIGZyYWdtZW50TWFpbihkYXRhOiBUcmFuc2ZlcikgLT4gW1tsb2NhdGlvbigwKV1dIHZlYzQ8ZjMyPiB7DQoJcmV0dXJuIHZlYzQ8ZjMyPihkYXRhLmNvbG9yLCAxLjApOw0KfQ0K";

	let pipeline$3 = undefined;
	function Render$3(position, length, positions, colors) {
	    if (pipeline$3 == undefined) {
	        const module = NewModule(ConvertURI(srcURI$3));
	        pipeline$3 = device.createRenderPipeline({
	            vertex: {
	                module: module,
	                entryPoint: 'vertexMain',
	                buffers: [
	                    {
	                        attributes: [
	                            {
	                                shaderLocation: 0,
	                                offset: 0 * 4,
	                                format: 'float32x3',
	                            },
	                        ],
	                        arrayStride: 4 * 4,
	                        stepMode: 'vertex',
	                    },
	                    {
	                        attributes: [
	                            {
	                                shaderLocation: 1,
	                                offset: 0 * 4,
	                                format: 'float32x3',
	                            },
	                        ],
	                        arrayStride: 4 * 4,
	                        stepMode: 'vertex',
	                    },
	                ],
	            },
	            fragment: {
	                module: module,
	                entryPoint: 'fragmentMain',
	                targets: [
	                    {
	                        format: format,
	                    },
	                ],
	            },
	            depthStencil: {
	                format: 'depth32float',
	                depthWriteEnabled: true,
	                depthCompare: 'less',
	            },
	            primitive: {
	                topology: 'line-list',
	            },
	        });
	    }
	    const array = new Float32Array(16);
	    position.Save(array, 0);
	    const buffer = CreateBuffer(array, GPUBufferUsage.UNIFORM);
	    renderPass.setPipeline(pipeline$3);
	    const group = device.createBindGroup({
	        layout: pipeline$3.getBindGroupLayout(0),
	        entries: [
	            {
	                binding: 0,
	                resource: { buffer: cameraBuffer },
	            },
	            {
	                binding: 1,
	                resource: { buffer: buffer },
	            },
	        ],
	    });
	    renderPass.setBindGroup(0, group);
	    renderPass.setVertexBuffer(0, positions);
	    renderPass.setVertexBuffer(1, colors);
	    renderPass.draw(length);
	}

	var srcURI$2 = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBDYW1lcmEgew0KCXByb2plY3Rpb246IG1hdDR4NDxmMzI+Ow0KCXZpZXc6IG1hdDR4NDxmMzI+Ow0KfTsNCg0KW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgew0KCW1vZGVsOiBtYXQ0eDQ8ZjMyPjsNCglyYWRpdXM6IGYzMjsNCglhc3BlY3Q6IGYzMjsNCn07DQoNCg0KW1tncm91cCgwKSwgYmluZGluZygwKV1dIHZhcjx1bmlmb3JtPiBjYW1lcmE6IENhbWVyYTsNCltbZ3JvdXAoMCksIGJpbmRpbmcoMSldXSB2YXI8dW5pZm9ybT4gcGFyYW1ldGVyOiBQYXJhbWV0ZXI7DQoNCnN0cnVjdCBUcmFuc2ZlciB7DQoJW1tidWlsdGluKHBvc2l0aW9uKV1dIHBvc2l0aW9uIDogdmVjNDxmMzI+Ow0KCVtbbG9jYXRpb24oMCldXSBvZmZzZXQgOiB2ZWMyPGYzMj47DQoJW1tsb2NhdGlvbigxKV1dIGNvbG9yIDogdmVjMzxmMzI+Ow0KfTsNCg0KW1tzdGFnZSh2ZXJ0ZXgpXV0NCmZuIHZlcnRleE1haW4oDQoJW1tsb2NhdGlvbigwKV1dIG9mZnNldDogdmVjMjxmMzI+LA0KCVtbbG9jYXRpb24oMSldXSBwb3NpdGlvbiA6IHZlYzM8ZjMyPiwNCglbW2xvY2F0aW9uKDIpXV0gY29sb3I6IHZlYzM8ZjMyPiwNCikgLT4gVHJhbnNmZXIgew0KCXZhciBvdXRwdXQgOiBUcmFuc2ZlcjsNCglvdXRwdXQucG9zaXRpb24gPSBjYW1lcmEucHJvamVjdGlvbiAqIGNhbWVyYS52aWV3ICogcGFyYW1ldGVyLm1vZGVsICogdmVjNDxmMzI+KHBvc2l0aW9uLCAxLjApOw0KCW91dHB1dC5wb3NpdGlvbi54ID0gb3V0cHV0LnBvc2l0aW9uLnggKyBvZmZzZXQueCAqIHBhcmFtZXRlci5yYWRpdXM7DQoJb3V0cHV0LnBvc2l0aW9uLnkgPSBvdXRwdXQucG9zaXRpb24ueSArIG9mZnNldC55ICogcGFyYW1ldGVyLnJhZGl1cyAqIHBhcmFtZXRlci5hc3BlY3Q7DQoJb3V0cHV0Lm9mZnNldCA9IG9mZnNldDsNCglvdXRwdXQuY29sb3IgPSBhYnMoY29sb3IpOw0KCXJldHVybiBvdXRwdXQ7DQp9DQoNCltbc3RhZ2UoZnJhZ21lbnQpXV0NCmZuIGZyYWdtZW50TWFpbihpbnB1dCA6IFRyYW5zZmVyKSAtPiBbW2xvY2F0aW9uKDApXV0gdmVjNDxmMzI+IHsNCglpZiAobGVuZ3RoKGlucHV0Lm9mZnNldCkgPj0gMS4wKSB7DQoJCWRpc2NhcmQ7DQoJfQ0KCXJldHVybiB2ZWM0PGYzMj4oaW5wdXQuY29sb3IsIDEuMCk7DQp9DQo=";

	let quadBuffer = undefined;
	let pipeline$2 = undefined;
	function Render$2(position, radius, length, positions, colors) {
	    if (pipeline$2 == undefined || quadBuffer == undefined) {
	        const module = NewModule(ConvertURI(srcURI$2));
	        pipeline$2 = device.createRenderPipeline({
	            vertex: {
	                module: module,
	                entryPoint: 'vertexMain',
	                buffers: [
	                    {
	                        attributes: [
	                            {
	                                shaderLocation: 0,
	                                offset: 0 * 4,
	                                format: 'float32x2',
	                            },
	                        ],
	                        arrayStride: 2 * 4,
	                        stepMode: 'vertex',
	                    },
	                    {
	                        attributes: [
	                            {
	                                shaderLocation: 1,
	                                offset: 0 * 4,
	                                format: 'float32x3',
	                            },
	                        ],
	                        arrayStride: 4 * 4,
	                        stepMode: 'instance',
	                    },
	                    {
	                        attributes: [
	                            {
	                                shaderLocation: 2,
	                                offset: 0 * 4,
	                                format: 'float32x3',
	                            },
	                        ],
	                        arrayStride: 4 * 4,
	                        stepMode: 'instance',
	                    },
	                ],
	            },
	            fragment: {
	                module: module,
	                entryPoint: 'fragmentMain',
	                targets: [
	                    {
	                        format: format,
	                    },
	                ],
	            },
	            depthStencil: {
	                format: 'depth32float',
	                depthWriteEnabled: true,
	                depthCompare: 'less',
	            },
	            primitive: {
	                topology: 'triangle-strip',
	                stripIndexFormat: 'uint32',
	                cullMode: 'back',
	            },
	        });
	        quadBuffer = CreateBuffer(new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]), GPUBufferUsage.VERTEX);
	    }
	    const array = new Float32Array(16 + 2);
	    position.Save(array, 0);
	    array[16] = radius;
	    array[17] = aspect();
	    const buffer = CreateBuffer(array, GPUBufferUsage.UNIFORM);
	    renderPass.setPipeline(pipeline$2);
	    const group = device.createBindGroup({
	        layout: pipeline$2.getBindGroupLayout(0),
	        entries: [
	            {
	                binding: 0,
	                resource: { buffer: cameraBuffer },
	            },
	            {
	                binding: 1,
	                resource: { buffer: buffer },
	            },
	        ],
	    });
	    renderPass.setBindGroup(0, group);
	    renderPass.setVertexBuffer(0, quadBuffer);
	    renderPass.setVertexBuffer(1, positions);
	    renderPass.setVertexBuffer(2, colors);
	    renderPass.draw(4, length);
	}

	var srcURI$1 = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBDYW1lcmEgew0KCXByb2plY3Rpb246IG1hdDR4NDxmMzI+Ow0KCXZpZXc6IG1hdDR4NDxmMzI+Ow0KfTsNCg0KW1tibG9ja11dIHN0cnVjdCBQYXJhbWV0ZXIgew0KCW1vZGVsOiBtYXQ0eDQ8ZjMyPjsNCglrOiB1MzI7DQp9Ow0KDQpbW2Jsb2NrXV0gc3RydWN0IEJ1ZmZlciB7DQoJZGF0YTogYXJyYXk8dmVjMzxmMzI+PjsNCn07DQoNCltbYmxvY2tdXSBzdHJ1Y3QgSW5kaWNlcyB7DQoJZGF0YTogYXJyYXk8dTMyPjsNCn07DQoNCg0KW1tncm91cCgwKSwgYmluZGluZygwKV1dIHZhcjx1bmlmb3JtPiBjYW1lcmE6IENhbWVyYTsNCltbZ3JvdXAoMCksIGJpbmRpbmcoMSldXSB2YXI8dW5pZm9ybT4gcGFyYW1ldGVyOiBQYXJhbWV0ZXI7DQpbW2dyb3VwKDApLCBiaW5kaW5nKDIpXV0gdmFyPHN0b3JhZ2UsIHJlYWQ+IHBvc2l0aW9uczogQnVmZmVyOw0KW1tncm91cCgwKSwgYmluZGluZygzKV1dIHZhcjxzdG9yYWdlLCByZWFkPiBjb2xvcnM6IEJ1ZmZlcjsNCltbZ3JvdXAoMCksIGJpbmRpbmcoNCldXSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5kaWNlczogSW5kaWNlczsNCg0Kc3RydWN0IFRyYW5zZmVyIHsNCglbW2J1aWx0aW4ocG9zaXRpb24pXV0gcG9zaXRpb24gOiB2ZWM0PGYzMj47DQoJW1tsb2NhdGlvbigwKV1dIGNvbG9yOiB2ZWMzPGYzMj47DQp9Ow0KDQpbW3N0YWdlKHZlcnRleCldXQ0KZm4gdmVydGV4TWFpbigNCglbW2J1aWx0aW4odmVydGV4X2luZGV4KV1dIGlkOiB1MzIsDQopIC0+IFRyYW5zZmVyIHsNCgl2YXIgdmVydGV4ID0gcG9zaXRpb25zLmRhdGFbaWQgLyAoMnUgKiBwYXJhbWV0ZXIuayldOw0KCXZhciBjb2xvciA9IGNvbG9ycy5kYXRhW2lkIC8gKDJ1ICogcGFyYW1ldGVyLmspXTsNCglpZiAoaWQlMnUgIT0gMHUpIHsNCgkJdmVydGV4ID0gKHZlcnRleCArIHBvc2l0aW9ucy5kYXRhW2luZGljZXMuZGF0YVtpZC8ydV0gXSkgLyAyLjA7DQoJfQ0KCXZhciBvdXRwdXQgOiBUcmFuc2ZlcjsNCglvdXRwdXQucG9zaXRpb24gPSBjYW1lcmEucHJvamVjdGlvbiAqIGNhbWVyYS52aWV3ICogcGFyYW1ldGVyLm1vZGVsICogdmVjNDxmMzI+KHZlcnRleCwgMS4wKTsNCgkNCglvdXRwdXQuY29sb3IgPSBhYnMoY29sb3IpOw0KDQoJcmV0dXJuIG91dHB1dDsNCn0NCg0KW1tzdGFnZShmcmFnbWVudCldXQ0KZm4gZnJhZ21lbnRNYWluKGRhdGE6IFRyYW5zZmVyKSAtPiBbW2xvY2F0aW9uKDApXV0gdmVjNDxmMzI+IHsNCglyZXR1cm4gdmVjNDxmMzI+KGRhdGEuY29sb3IsIDEuMCk7DQp9DQo=";

	let pipeline$1 = undefined;
	function Render$1(position, positions, colors, nearest, k, length) {
	    if (pipeline$1 == undefined) {
	        const module = NewModule(ConvertURI(srcURI$1));
	        pipeline$1 = device.createRenderPipeline({
	            vertex: {
	                module: module,
	                entryPoint: 'vertexMain',
	                buffers: [],
	            },
	            fragment: {
	                module: module,
	                entryPoint: 'fragmentMain',
	                targets: [
	                    {
	                        format: format,
	                    },
	                ],
	            },
	            depthStencil: {
	                format: 'depth32float',
	                depthWriteEnabled: true,
	                depthCompare: 'less',
	            },
	            primitive: {
	                topology: 'line-list',
	            },
	        });
	    }
	    const array = new Float32Array(16 + 1);
	    position.Save(array, 0);
	    new Uint32Array(array.buffer)[16] = k;
	    const buffer = CreateBuffer(array, GPUBufferUsage.UNIFORM);
	    renderPass.setPipeline(pipeline$1);
	    const group = device.createBindGroup({
	        layout: pipeline$1.getBindGroupLayout(0),
	        entries: [
	            {
	                binding: 0,
	                resource: { buffer: cameraBuffer },
	            },
	            {
	                binding: 1,
	                resource: { buffer: buffer },
	            },
	            {
	                binding: 2,
	                resource: { buffer: positions },
	            },
	            {
	                binding: 3,
	                resource: { buffer: colors },
	            },
	            {
	                binding: 4,
	                resource: { buffer: nearest },
	            },
	        ],
	    });
	    renderPass.setBindGroup(0, group);
	    renderPass.draw(length * k * 2);
	}

	var srcURI = "data:null;base64,W1tibG9ja11dIHN0cnVjdCBDYW1lcmEgewoJcHJvamVjdGlvbjogbWF0NHg0PGYzMj47Cgl2aWV3OiBtYXQ0eDQ8ZjMyPjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgUGFyYW1ldGVyIHsKCW1vZGVsOiBtYXQ0eDQ8ZjMyPjsKCWs6IHUzMjsKfTsKCltbYmxvY2tdXSBzdHJ1Y3QgQnVmZmVyIHsKCWRhdGE6IGFycmF5PHZlYzM8ZjMyPj47Cn07CgpbW2Jsb2NrXV0gc3RydWN0IEluZGljZXMgewoJZGF0YTogYXJyYXk8dTMyPjsKfTsKCltbZ3JvdXAoMCksIGJpbmRpbmcoMCldXSB2YXI8dW5pZm9ybT4gY2FtZXJhOiBDYW1lcmE7CltbZ3JvdXAoMCksIGJpbmRpbmcoMSldXSB2YXI8dW5pZm9ybT4gcGFyYW1ldGVyOiBQYXJhbWV0ZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMildXSB2YXI8c3RvcmFnZSwgcmVhZD4gcG9zaXRpb25zOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoMyldXSB2YXI8c3RvcmFnZSwgcmVhZD4gY29sb3JzOiBCdWZmZXI7CltbZ3JvdXAoMCksIGJpbmRpbmcoNCldXSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5kaWNlczogSW5kaWNlczsKCnN0cnVjdCBUcmFuc2ZlciB7CglbW2J1aWx0aW4ocG9zaXRpb24pXV0gcG9zaXRpb24gOiB2ZWM0PGYzMj47CglbW2xvY2F0aW9uKDApXV0gY29sb3I6IHZlYzM8ZjMyPjsKfTsKCltbc3RhZ2UodmVydGV4KV1dCmZuIHZlcnRleE1haW4oCglbW2J1aWx0aW4odmVydGV4X2luZGV4KV1dIGlkOiB1MzIsCikgLT4gVHJhbnNmZXIgewoJdmFyIGluZGV4X2lkOiB1MzI7CglsZXQgY2VudGVyID0gaWQgLyAoM3UgKiBwYXJhbWV0ZXIuayk7Cglzd2l0Y2ggKGlkJTN1KSB7CgkJY2FzZSAwdTogewoJCQlpbmRleF9pZCA9IGNlbnRlcjsKCQkJYnJlYWs7CgkJfQoJCWNhc2UgMXU6IHsKCQkJaW5kZXhfaWQgPSBpbmRpY2VzLmRhdGFbaWQvM3VdOwoJCQlicmVhazsKCQl9CgkJZGVmYXVsdDogewoJCQlpbmRleF9pZCA9IGluZGljZXMuZGF0YVtpZC8zdSArIDF1XTsKCQkJaWYgKGluZGV4X2lkID09IGNlbnRlciB8fCAoaWQgKyAxdSklKHBhcmFtZXRlci5rICogM3UpID09IDB1KSB7IC8vbG9vcCBhcm91bmQgdG8gdGhlIGZpcnN0IHZlcnRleCBpbiB0aGUgY2lyY2xlCgkJCQlpbmRleF9pZCA9IGluZGljZXMuZGF0YVtjZW50ZXIqcGFyYW1ldGVyLmtdOwoJCQl9CgkJCWJyZWFrOwoJCX0KCX0KCgl2YXIgb3V0cHV0IDogVHJhbnNmZXI7CglvdXRwdXQucG9zaXRpb24gPSBjYW1lcmEucHJvamVjdGlvbiAqIGNhbWVyYS52aWV3ICogcGFyYW1ldGVyLm1vZGVsICogdmVjNDxmMzI+KHBvc2l0aW9ucy5kYXRhW2luZGV4X2lkXSwgMS4wKTsKCW91dHB1dC5jb2xvciA9IGFicyhjb2xvcnMuZGF0YVtjZW50ZXJdKTsKCXJldHVybiBvdXRwdXQ7Cn0KCltbc3RhZ2UoZnJhZ21lbnQpXV0KZm4gZnJhZ21lbnRNYWluKGRhdGE6IFRyYW5zZmVyKSAtPiBbW2xvY2F0aW9uKDApXV0gdmVjNDxmMzI+IHsKCXJldHVybiB2ZWM0PGYzMj4oZGF0YS5jb2xvciwgMS4wKTsKfQo=";

	let pipeline = undefined;
	const K = 16;
	function Render(position, positions, colors, nearest, k, length) {
	    if (pipeline == undefined) {
	        const module = NewModule(ConvertURI(srcURI));
	        pipeline = device.createRenderPipeline({
	            vertex: {
	                module: module,
	                entryPoint: 'vertexMain',
	                buffers: [],
	            },
	            fragment: {
	                module: module,
	                entryPoint: 'fragmentMain',
	                targets: [
	                    {
	                        format: format,
	                    },
	                ],
	            },
	            depthStencil: {
	                format: 'depth32float',
	                depthWriteEnabled: true,
	                depthCompare: 'less',
	            },
	            primitive: {
	                topology: 'triangle-list',
	            },
	        });
	    }
	    const array = new Float32Array(16 + 1);
	    position.Save(array, 0);
	    new Uint32Array(array.buffer)[16] = k;
	    const buffer = CreateBuffer(array, GPUBufferUsage.UNIFORM);
	    renderPass.setPipeline(pipeline);
	    const group = device.createBindGroup({
	        layout: pipeline.getBindGroupLayout(0),
	        entries: [
	            {
	                binding: 0,
	                resource: { buffer: cameraBuffer },
	            },
	            {
	                binding: 1,
	                resource: { buffer: buffer },
	            },
	            {
	                binding: 2,
	                resource: { buffer: positions },
	            },
	            {
	                binding: 3,
	                resource: { buffer: colors },
	            },
	            {
	                binding: 4,
	                resource: { buffer: nearest },
	            },
	        ],
	    });
	    renderPass.setBindGroup(0, group);
	    renderPass.draw(length * k * 3);
	}

	async function Sort(data, length) {
	    const arr = new Float32Array(await ReadBuffer(data, length * 4 * 4));
	    quickSort(arr, 0, length - 1);
	    device.queue.writeBuffer(data, 0, arr);
	}
	function quickSort(arr, low, high) {
	    if (low < high) {
	        const id = Math.floor((low + high) / 2);
	        swap(arr, id, high);
	        const pivot = arr[high * 4];
	        let i = (low - 1);
	        for (let j = low; j <= high - 1; j++) {
	            if (arr[j * 4] < pivot) {
	                i++;
	                swap(arr, i, j);
	            }
	        }
	        swap(arr, i + 1, high);
	        const pi = (i + 1);
	        quickSort(arr, low, pi - 1);
	        quickSort(arr, pi + 1, high);
	    }
	}
	function swap(arr, a, b) {
	    const t0 = arr[a * 4 + 0];
	    const t1 = arr[a * 4 + 1];
	    const t2 = arr[a * 4 + 2];
	    const t3 = arr[a * 4 + 3];
	    arr[a * 4 + 0] = arr[b * 4 + 0];
	    arr[a * 4 + 1] = arr[b * 4 + 1];
	    arr[a * 4 + 2] = arr[b * 4 + 2];
	    arr[a * 4 + 3] = arr[b * 4 + 3];
	    arr[b * 4 + 0] = t0;
	    arr[b * 4 + 1] = t1;
	    arr[b * 4 + 2] = t2;
	    arr[b * 4 + 3] = t3;
	}

	async function Setup(width, height) {
	    const c = await Setup$2(width, height);
	    if (c == undefined) {
	        return undefined;
	    }
	    Setup$1();
	    return c;
	}

	function Create$5(points) {
	    const colors = new Float32Array(points * 4);
	    for (let i = 0; i < points; i++) {
	        colors[i * 4 + 0] = 0.2 + 0.5 * Math.random();
	        colors[i * 4 + 1] = 0.2 + 0.5 * Math.random();
	        colors[i * 4 + 2] = 0.2 + 0.5 * Math.random();
	    }
	    return CreateBuffer(colors, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	}

	function Create$4(points, noise = 0.001) {
	    const vertices = new Float32Array(points * 4);
	    for (let i = 0; i < points; i++) {
	        switch (Math.floor(Math.random() * 6)) {
	            case 0:
	                vertices[i * 4 + 0] = Math.random() * 2 - 1;
	                vertices[i * 4 + 1] = Math.random() * 2 - 1;
	                vertices[i * 4 + 2] = -1;
	                break;
	            case 1:
	                vertices[i * 4 + 0] = Math.random() * 2 - 1;
	                vertices[i * 4 + 1] = Math.random() * 2 - 1;
	                vertices[i * 4 + 2] = 1;
	                break;
	            case 2:
	                vertices[i * 4 + 0] = Math.random() * 2 - 1;
	                vertices[i * 4 + 1] = -1;
	                vertices[i * 4 + 2] = Math.random() * 2 - 1;
	                break;
	            case 3:
	                vertices[i * 4 + 0] = Math.random() * 2 - 1;
	                vertices[i * 4 + 1] = 1;
	                vertices[i * 4 + 2] = Math.random() * 2 - 1;
	                break;
	            case 4:
	                vertices[i * 4 + 0] = -1;
	                vertices[i * 4 + 1] = Math.random() * 2 - 1;
	                vertices[i * 4 + 2] = Math.random() * 2 - 1;
	                break;
	            case 5:
	                vertices[i * 4 + 0] = 1;
	                vertices[i * 4 + 1] = Math.random() * 2 - 1;
	                vertices[i * 4 + 2] = Math.random() * 2 - 1;
	                break;
	        }
	        vertices[i * 4 + 0] += noise * Math.random();
	        vertices[i * 4 + 1] += noise * Math.random();
	        vertices[i * 4 + 2] += noise * Math.random();
	    }
	    return CreateBuffer(vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	}

	function Create$3(amount) {
	    const positions = new Float32Array((amount * 4 + 3) * 8);
	    const colors = new Float32Array((amount * 4 + 3) * 8);
	    const addLine = (idx, start, end, color, endColor = undefined) => {
	        if (endColor == undefined) {
	            endColor = color;
	        }
	        idx *= 8;
	        positions[idx + 0] = start.x;
	        positions[idx + 1] = start.y;
	        positions[idx + 2] = start.z;
	        colors[idx + 0] = color.x;
	        colors[idx + 1] = color.y;
	        colors[idx + 2] = color.z;
	        positions[idx + 4] = end.x;
	        positions[idx + 5] = end.y;
	        positions[idx + 6] = end.z;
	        colors[idx + 4] = endColor.x;
	        colors[idx + 5] = endColor.y;
	        colors[idx + 6] = endColor.z;
	    };
	    for (let i = -amount; i <= amount; i++) {
	        if (i == 0) {
	            continue;
	        }
	        let idx;
	        if (i < 0) {
	            idx = i;
	        }
	        else if (i == 0) {
	            continue;
	        }
	        else {
	            idx = i - 1;
	        }
	        addLine(amount * 1 + idx, { x: i, y: 0, z: amount }, { x: i, y: 0, z: -amount }, { x: 0, y: 0, z: 0 });
	        addLine(amount * 3 + idx, { x: amount, y: 0, z: i }, { x: -amount, y: 0, z: i }, { x: 0, y: 0, z: 0 });
	    }
	    addLine(amount * 4 + 0, { x: -amount, y: 0, z: 0 }, { x: amount, y: 0, z: 0 }, { x: 0, y: 0, z: 0 }, { x: 1, y: 0, z: 0 });
	    addLine(amount * 4 + 1, { x: 0, y: -amount, z: 0 }, { x: 0, y: amount, z: 0 }, { x: 0, y: 0, z: 0 }, { x: 0, y: 1, z: 0 });
	    addLine(amount * 4 + 2, { x: 0, y: 0, z: -amount }, { x: 0, y: 0, z: amount }, { x: 0, y: 0, z: 0 }, { x: 0, y: 0, z: 1 });
	    return {
	        length: (amount * 4 + 3) * 2,
	        positions: CreateBuffer(positions, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE),
	        colors: CreateBuffer(colors, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE),
	    };
	}

	function LZF(inData, outLength) {
	    const inLength = inData.length;
	    const outData = new Uint8Array(outLength);
	    let inPtr = 0;
	    let outPtr = 0;
	    do {
	        let ctrl = inData[inPtr++];
	        if (ctrl < 1 << 5) {
	            ctrl++;
	            if (outPtr + ctrl > outLength)
	                throw new Error('Output buffer is not large enough');
	            if (inPtr + ctrl > inLength)
	                throw new Error('Invalid compressed data');
	            do {
	                outData[outPtr++] = inData[inPtr++];
	            } while (--ctrl);
	        }
	        else {
	            let len = ctrl >> 5;
	            let ref = outPtr - ((ctrl & 0x1f) << 8) - 1;
	            if (inPtr >= inLength)
	                throw new Error('Invalid compressed data');
	            if (len === 7) {
	                len += inData[inPtr++];
	                if (inPtr >= inLength)
	                    throw new Error('Invalid compressed data');
	            }
	            ref -= inData[inPtr++];
	            if (outPtr + len + 2 > outLength)
	                throw new Error('Output buffer is not large enough');
	            if (ref < 0)
	                throw new Error('Invalid compressed data');
	            if (ref >= outPtr)
	                throw new Error('Invalid compressed data');
	            do {
	                outData[outPtr++] = outData[ref++];
	            } while (--len + 2);
	        }
	    } while (inPtr < inLength);
	    return outData;
	}

	const littleEndian = true;
	function Create$2(data) {
	    const header = parseHeader(data);
	    if (header == null) {
	        return undefined;
	    }
	    const offset = header.offset;
	    let position = undefined;
	    if (offset.x !== undefined && offset.y !== undefined && offset.z !== undefined) {
	        position = new Float32Array(header.points * 4);
	    }
	    let color = undefined;
	    let color_offset = undefined;
	    if (offset.rgb !== undefined || offset.rgba !== undefined) {
	        color = new Float32Array(header.points * 4);
	        color_offset = offset.rgb === undefined ? offset.rgba : offset.rgb;
	    }
	    if (header.data === 'ascii') {
	        const charArrayView = new Uint8Array(data);
	        let dataString = '';
	        for (let j = header.headerLen; j < data.byteLength; j++) {
	            dataString += String.fromCharCode(charArrayView[j]);
	        }
	        const lines = dataString.split('\n');
	        let i3 = 0;
	        for (let i = 0; i < lines.length; i++, i3 += 4) {
	            const line = lines[i].split(' ');
	            if (position !== undefined) {
	                position[i3 + 0] = parseFloat(line[offset.x]);
	                position[i3 + 1] = parseFloat(line[offset.y]);
	                position[i3 + 2] = parseFloat(line[offset.z]);
	            }
	            if (color !== undefined) {
	                let c = undefined;
	                if (offset.rgba !== undefined) {
	                    c = new Uint32Array([parseInt(line[offset.rgba])]);
	                }
	                else if (offset.rgb !== undefined) {
	                    c = new Float32Array([parseFloat(line[offset.rgb])]);
	                }
	                const dataview = new Uint8Array(c.buffer, 0);
	                color[i3 + 2] = dataview[0] / 255.0;
	                color[i3 + 1] = dataview[1] / 255.0;
	                color[i3 + 0] = dataview[2] / 255.0;
	            }
	        }
	    }
	    else if (header.data === 'binary') {
	        let row = 0;
	        const dataArrayView = new DataView(data, header.headerLen);
	        for (let p = 0; p < header.points; row += header.rowSize, p++) {
	            if (position !== undefined) {
	                position[p * 4 + 0] = dataArrayView.getFloat32(row + offset.x, littleEndian);
	                position[p * 4 + 1] = dataArrayView.getFloat32(row + offset.y, littleEndian);
	                position[p * 4 + 2] = dataArrayView.getFloat32(row + offset.z, littleEndian);
	            }
	            if (color !== undefined) {
	                color[p * 4 + 2] = dataArrayView.getUint8(row + color_offset + 0) / 255.0;
	                color[p * 4 + 1] = dataArrayView.getUint8(row + color_offset + 1) / 255.0;
	                color[p * 4 + 0] = dataArrayView.getUint8(row + color_offset + 2) / 255.0;
	            }
	        }
	    }
	    else if (header.data === 'binary_compressed') {
	        const sizes = new Uint32Array(data.slice(header.headerLen, header.headerLen + 8));
	        const compressedSize = sizes[0];
	        const decompressedSize = sizes[1];
	        const decompressed = LZF(new Uint8Array(data, header.headerLen + 8, compressedSize), decompressedSize);
	        const dataArrayView = new DataView(decompressed.buffer);
	        for (let p = 0; p < header.points; p++) {
	            if (position !== undefined) {
	                position[p * 4 + 0] = dataArrayView.getFloat32(offset.x + p * 4, littleEndian);
	                position[p * 4 + 1] = dataArrayView.getFloat32(offset.y + p * 4, littleEndian);
	                position[p * 4 + 2] = dataArrayView.getFloat32(offset.z + p * 4, littleEndian);
	            }
	            if (color !== undefined) {
	                color[p * 4 + 2] = dataArrayView.getUint8(color_offset + p * 4 + 0) / 255.0;
	                color[p * 4 + 1] = dataArrayView.getUint8(color_offset + p * 4 + 1) / 255.0;
	                color[p * 4 + 0] = dataArrayView.getUint8(color_offset + p * 4 + 2) / 255.0;
	            }
	        }
	    }
	    if (position == undefined) {
	        return undefined;
	    }
	    let x = 0;
	    let y = 0;
	    let z = 0;
	    for (let i = 0; i < position.length; i += 4) {
	        x += position[i + 0];
	        y += position[i + 1];
	        z += position[i + 2];
	    }
	    x /= position.length / 4;
	    y /= position.length / 4;
	    z /= position.length / 4;
	    for (let i = 0; i < position.length; i += 4) {
	        position[i + 0] -= x;
	        position[i + 1] -= y;
	        position[i + 2] -= z;
	    }
	    console.log('Size:', position.length / 4);
	    return [
	        CreateBuffer(position, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE),
	        header.points,
	    ];
	}
	function parseHeader(binaryData) {
	    let headerText = '';
	    const charArray = new Uint8Array(binaryData);
	    let i = 0;
	    const max = charArray.length;
	    while (i < max && headerText.search(/[\r\n]DATA\s(\S*)\s/i) === -1) {
	        headerText += String.fromCharCode(charArray[i++]);
	    }
	    const result1 = headerText.search(/[\r\n]DATA\s(\S*)\s/i);
	    const result2 = /[\r\n]DATA\s(\S*)\s/i.exec(headerText.substr(result1 - 1));
	    if (result1 == undefined || result2 == undefined) {
	        return null;
	    }
	    const header = {};
	    header.data = result2[1];
	    header.headerLen = result2[0].length + result1;
	    header.str = headerText.substr(0, header.headerLen);
	    header.str = header.str.replace(/#.*/gi, '');
	    const version = /VERSION (.*)/i.exec(header.str);
	    if (version !== null) {
	        header.version = parseFloat(version[1]);
	    }
	    const fields = /FIELDS (.*)/i.exec(header.str);
	    if (fields !== null) {
	        header.fields = fields[1].split(' ');
	    }
	    const size = /SIZE (.*)/i.exec(header.str);
	    if (size !== null) {
	        header.size = size[1].split(' ').map(function (x) {
	            return parseInt(x, 10);
	        });
	    }
	    const type = /TYPE (.*)/i.exec(header.str);
	    if (type !== null) {
	        header.type = type[1].split(' ');
	    }
	    const count = /COUNT (.*)/i.exec(header.str);
	    if (count !== null) {
	        header.count = count[1].split(' ').map(function (x) {
	            return parseInt(x, 10);
	        });
	    }
	    const width = /WIDTH (.*)/i.exec(header.str);
	    if (width !== null) {
	        header.width = parseInt(width[1]);
	    }
	    const height = /HEIGHT (.*)/i.exec(header.str);
	    if (height !== null) {
	        header.height = parseInt(height[1]);
	    }
	    const viewpoint = /VIEWPOINT (.*)/i.exec(header.str);
	    if (viewpoint !== null) {
	        header.viewpoint = viewpoint[1];
	    }
	    const points = /POINTS (.*)/i.exec(header.str);
	    if (points !== null) {
	        header.points = parseInt(points[1], 10);
	    }
	    if (header.points === null) {
	        header.points = header.width * header.height;
	    }
	    if (header.count == undefined) {
	        header.count = [];
	        for (i = 0; i < header.fields.length; i++) {
	            header.count.push(1);
	        }
	    }
	    header.offset = {};
	    let sizeSum = 0;
	    for (let j = 0; j < header.fields.length; j++) {
	        if (header.data === 'ascii') {
	            header.offset[header.fields[j]] = j;
	        }
	        else if (header.data === 'binary') {
	            header.offset[header.fields[j]] = sizeSum;
	            sizeSum += header.size[j];
	        }
	        else if (header.data === 'binary_compressed') {
	            header.offset[header.fields[j]] = sizeSum;
	            sizeSum += header.size[j] * header.points;
	        }
	    }
	    header.rowSize = sizeSum;
	    return header;
	}

	function Create$1(points) {
	    const vertices = new Float32Array(points * 4);
	    for (let i = 0; i < points; i++) {
	        const long = Math.acos(Math.random() * 2 - 1);
	        const lat = Math.random() * 2 * Math.PI;
	        vertices[i * 4 + 0] = Math.sin(lat) * Math.sin(long);
	        vertices[i * 4 + 1] = Math.cos(long);
	        vertices[i * 4 + 2] = Math.cos(lat) * Math.sin(long);
	    }
	    return CreateBuffer(vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	}

	const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
	const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;
	const F3 = 1.0 / 3.0;
	const G3 = 1.0 / 6.0;
	const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;
	const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;
	const grad3 = new Float32Array([1, 1, 0,
	    -1, 1, 0,
	    1, -1, 0,
	    -1, -1, 0,
	    1, 0, 1,
	    -1, 0, 1,
	    1, 0, -1,
	    -1, 0, -1,
	    0, 1, 1,
	    0, -1, 1,
	    0, 1, -1,
	    0, -1, -1]);
	const grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,
	    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,
	    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,
	    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,
	    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,
	    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,
	    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,
	    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);
	class SimplexNoise {
	    p;
	    perm;
	    permMod12;
	    constructor(randomOrSeed = Math.random) {
	        const random = typeof randomOrSeed == 'function' ? randomOrSeed : alea(randomOrSeed);
	        this.p = buildPermutationTable(random);
	        this.perm = new Uint8Array(512);
	        this.permMod12 = new Uint8Array(512);
	        for (let i = 0; i < 512; i++) {
	            this.perm[i] = this.p[i & 255];
	            this.permMod12[i] = this.perm[i] % 12;
	        }
	    }
	    noise2D(x, y) {
	        const permMod12 = this.permMod12;
	        const perm = this.perm;
	        let n0 = 0;
	        let n1 = 0;
	        let n2 = 0;
	        const s = (x + y) * F2;
	        const i = Math.floor(x + s);
	        const j = Math.floor(y + s);
	        const t = (i + j) * G2;
	        const X0 = i - t;
	        const Y0 = j - t;
	        const x0 = x - X0;
	        const y0 = y - Y0;
	        let i1, j1;
	        if (x0 > y0) {
	            i1 = 1;
	            j1 = 0;
	        }
	        else {
	            i1 = 0;
	            j1 = 1;
	        }
	        const x1 = x0 - i1 + G2;
	        const y1 = y0 - j1 + G2;
	        const x2 = x0 - 1.0 + 2.0 * G2;
	        const y2 = y0 - 1.0 + 2.0 * G2;
	        const ii = i & 255;
	        const jj = j & 255;
	        let t0 = 0.5 - x0 * x0 - y0 * y0;
	        if (t0 >= 0) {
	            const gi0 = permMod12[ii + perm[jj]] * 3;
	            t0 *= t0;
	            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0);
	        }
	        let t1 = 0.5 - x1 * x1 - y1 * y1;
	        if (t1 >= 0) {
	            const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
	            t1 *= t1;
	            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
	        }
	        let t2 = 0.5 - x2 * x2 - y2 * y2;
	        if (t2 >= 0) {
	            const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
	            t2 *= t2;
	            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
	        }
	        return 70.0 * (n0 + n1 + n2);
	    }
	    noise3D(x, y, z) {
	        const permMod12 = this.permMod12;
	        const perm = this.perm;
	        let n0, n1, n2, n3;
	        const s = (x + y + z) * F3;
	        const i = Math.floor(x + s);
	        const j = Math.floor(y + s);
	        const k = Math.floor(z + s);
	        const t = (i + j + k) * G3;
	        const X0 = i - t;
	        const Y0 = j - t;
	        const Z0 = k - t;
	        const x0 = x - X0;
	        const y0 = y - Y0;
	        const z0 = z - Z0;
	        let i1, j1, k1;
	        let i2, j2, k2;
	        if (x0 >= y0) {
	            if (y0 >= z0) {
	                i1 = 1;
	                j1 = 0;
	                k1 = 0;
	                i2 = 1;
	                j2 = 1;
	                k2 = 0;
	            }
	            else if (x0 >= z0) {
	                i1 = 1;
	                j1 = 0;
	                k1 = 0;
	                i2 = 1;
	                j2 = 0;
	                k2 = 1;
	            }
	            else {
	                i1 = 0;
	                j1 = 0;
	                k1 = 1;
	                i2 = 1;
	                j2 = 0;
	                k2 = 1;
	            }
	        }
	        else {
	            if (y0 < z0) {
	                i1 = 0;
	                j1 = 0;
	                k1 = 1;
	                i2 = 0;
	                j2 = 1;
	                k2 = 1;
	            }
	            else if (x0 < z0) {
	                i1 = 0;
	                j1 = 1;
	                k1 = 0;
	                i2 = 0;
	                j2 = 1;
	                k2 = 1;
	            }
	            else {
	                i1 = 0;
	                j1 = 1;
	                k1 = 0;
	                i2 = 1;
	                j2 = 1;
	                k2 = 0;
	            }
	        }
	        const x1 = x0 - i1 + G3;
	        const y1 = y0 - j1 + G3;
	        const z1 = z0 - k1 + G3;
	        const x2 = x0 - i2 + 2.0 * G3;
	        const y2 = y0 - j2 + 2.0 * G3;
	        const z2 = z0 - k2 + 2.0 * G3;
	        const x3 = x0 - 1.0 + 3.0 * G3;
	        const y3 = y0 - 1.0 + 3.0 * G3;
	        const z3 = z0 - 1.0 + 3.0 * G3;
	        const ii = i & 255;
	        const jj = j & 255;
	        const kk = k & 255;
	        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
	        if (t0 < 0)
	            n0 = 0.0;
	        else {
	            const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
	            t0 *= t0;
	            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
	        }
	        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
	        if (t1 < 0)
	            n1 = 0.0;
	        else {
	            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
	            t1 *= t1;
	            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
	        }
	        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
	        if (t2 < 0)
	            n2 = 0.0;
	        else {
	            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
	            t2 *= t2;
	            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
	        }
	        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
	        if (t3 < 0)
	            n3 = 0.0;
	        else {
	            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
	            t3 *= t3;
	            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
	        }
	        return 32.0 * (n0 + n1 + n2 + n3);
	    }
	    noise4D(x, y, z, w) {
	        const perm = this.perm;
	        let n0, n1, n2, n3, n4;
	        const s = (x + y + z + w) * F4;
	        const i = Math.floor(x + s);
	        const j = Math.floor(y + s);
	        const k = Math.floor(z + s);
	        const l = Math.floor(w + s);
	        const t = (i + j + k + l) * G4;
	        const X0 = i - t;
	        const Y0 = j - t;
	        const Z0 = k - t;
	        const W0 = l - t;
	        const x0 = x - X0;
	        const y0 = y - Y0;
	        const z0 = z - Z0;
	        const w0 = w - W0;
	        let rankx = 0;
	        let ranky = 0;
	        let rankz = 0;
	        let rankw = 0;
	        if (x0 > y0)
	            rankx++;
	        else
	            ranky++;
	        if (x0 > z0)
	            rankx++;
	        else
	            rankz++;
	        if (x0 > w0)
	            rankx++;
	        else
	            rankw++;
	        if (y0 > z0)
	            ranky++;
	        else
	            rankz++;
	        if (y0 > w0)
	            ranky++;
	        else
	            rankw++;
	        if (z0 > w0)
	            rankz++;
	        else
	            rankw++;
	        const i1 = rankx >= 3 ? 1 : 0;
	        const j1 = ranky >= 3 ? 1 : 0;
	        const k1 = rankz >= 3 ? 1 : 0;
	        const l1 = rankw >= 3 ? 1 : 0;
	        const i2 = rankx >= 2 ? 1 : 0;
	        const j2 = ranky >= 2 ? 1 : 0;
	        const k2 = rankz >= 2 ? 1 : 0;
	        const l2 = rankw >= 2 ? 1 : 0;
	        const i3 = rankx >= 1 ? 1 : 0;
	        const j3 = ranky >= 1 ? 1 : 0;
	        const k3 = rankz >= 1 ? 1 : 0;
	        const l3 = rankw >= 1 ? 1 : 0;
	        const x1 = x0 - i1 + G4;
	        const y1 = y0 - j1 + G4;
	        const z1 = z0 - k1 + G4;
	        const w1 = w0 - l1 + G4;
	        const x2 = x0 - i2 + 2.0 * G4;
	        const y2 = y0 - j2 + 2.0 * G4;
	        const z2 = z0 - k2 + 2.0 * G4;
	        const w2 = w0 - l2 + 2.0 * G4;
	        const x3 = x0 - i3 + 3.0 * G4;
	        const y3 = y0 - j3 + 3.0 * G4;
	        const z3 = z0 - k3 + 3.0 * G4;
	        const w3 = w0 - l3 + 3.0 * G4;
	        const x4 = x0 - 1.0 + 4.0 * G4;
	        const y4 = y0 - 1.0 + 4.0 * G4;
	        const z4 = z0 - 1.0 + 4.0 * G4;
	        const w4 = w0 - 1.0 + 4.0 * G4;
	        const ii = i & 255;
	        const jj = j & 255;
	        const kk = k & 255;
	        const ll = l & 255;
	        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
	        if (t0 < 0)
	            n0 = 0.0;
	        else {
	            const gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;
	            t0 *= t0;
	            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
	        }
	        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
	        if (t1 < 0)
	            n1 = 0.0;
	        else {
	            const gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;
	            t1 *= t1;
	            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
	        }
	        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
	        if (t2 < 0)
	            n2 = 0.0;
	        else {
	            const gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;
	            t2 *= t2;
	            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
	        }
	        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
	        if (t3 < 0)
	            n3 = 0.0;
	        else {
	            const gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;
	            t3 *= t3;
	            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
	        }
	        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
	        if (t4 < 0)
	            n4 = 0.0;
	        else {
	            const gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;
	            t4 *= t4;
	            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
	        }
	        return 27.0 * (n0 + n1 + n2 + n3 + n4);
	    }
	}
	function buildPermutationTable(random) {
	    const p = new Uint8Array(256);
	    for (let i = 0; i < 256; i++) {
	        p[i] = i;
	    }
	    for (let i = 0; i < 255; i++) {
	        const r = i + ~~(random() * (256 - i));
	        const aux = p[i];
	        p[i] = p[r];
	        p[r] = aux;
	    }
	    return p;
	}
	function alea(seed) {
	    let s0 = 0;
	    let s1 = 0;
	    let s2 = 0;
	    let c = 1;
	    const mash = masher();
	    s0 = mash(' ');
	    s1 = mash(' ');
	    s2 = mash(' ');
	    s0 -= mash(seed);
	    if (s0 < 0) {
	        s0 += 1;
	    }
	    s1 -= mash(seed);
	    if (s1 < 0) {
	        s1 += 1;
	    }
	    s2 -= mash(seed);
	    if (s2 < 0) {
	        s2 += 1;
	    }
	    return function () {
	        const t = 2091639 * s0 + c * 2.3283064365386963e-10;
	        s0 = s1;
	        s1 = s2;
	        return s2 = t - (c = t | 0);
	    };
	}
	function masher() {
	    let n = 0xefc8249d;
	    return function (data) {
	        data = data.toString();
	        for (let i = 0; i < data.length; i++) {
	            n += data.charCodeAt(i);
	            let h = 0.02519603282416938 * n;
	            n = h >>> 0;
	            h -= n;
	            h *= n;
	            n = h >>> 0;
	            h -= n;
	            n += h * 0x100000000;
	        }
	        return (n >>> 0) * 2.3283064365386963e-10;
	    };
	}

	function Create(points) {
	    const count = Math.floor(Math.sqrt(points));
	    const vertices = new Float32Array(count * count * 4);
	    const noise = new SimplexNoise();
	    for (let i = 0; i < count; i++) {
	        for (let j = 0; j < count; j++) {
	            vertices[(i * count + j) * 4 + 0] = i / count - 0.5;
	            vertices[(i * count + j) * 4 + 1] = noise.noise2D(i * 0.01, j * 0.01) / count * 25;
	            vertices[(i * count + j) * 4 + 2] = j / count - 0.5;
	            if (Math.random() <= 0.03) {
	                vertices[(i * count + j) * 4 + 1] += (0.5 + Math.random()) / count * 5;
	            }
	        }
	    }
	    return [
	        CreateBuffer(vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE),
	        count * count
	    ];
	}

	document.body.onload = async () => {
	    const mode = document.getElementById('mode');
	    const color = document.getElementById('color');
	    const gridCheckbox = document.getElementById('grid');
	    const display = document.getElementById('display');
	    const canvas = await Setup(display.clientWidth, display.clientHeight);
	    if (canvas == undefined) {
	        display.remove();
	        const error = document.createElement('div');
	        error.className = 'error';
	        const topLine = document.createElement('div');
	        topLine.className = 'large';
	        topLine.innerHTML = 'WebGPU not available';
	        error.append(topLine);
	        const botLine = document.createElement('div');
	        botLine.className = 'normal';
	        botLine.innerHTML =
	            'Only tested with <a href="https://www.google.com/chrome">Google Chrome</a>';
	        error.append(botLine);
	        document.body.append(error);
	        return;
	    }
	    display.append(canvas);
	    const cam = new Camera(Math.PI / 4);
	    cam.Translate(0, 5, 30);
	    const increase = new Position();
	    increase.Scale(5, 5, 5);
	    const normal = new Position();
	    const grid = Create$3(10);
	    let k = 64;
	    let length = 50_000;
	    let cloud = Create$1(length);
	    let colors = Create$5(length);
	    let nearest = undefined;
	    let normals = undefined;
	    let curvature = undefined;
	    let valid = true;
	    window.CreateForm = async (name) => {
	        const size = document.getElementById('size');
	        length = parseInt(size.value);
	        cloud.destroy();
	        colors.destroy();
	        valid = false;
	        switch (name) {
	            case 'sphere':
	                cloud = Create$1(length);
	                valid = true;
	                break;
	            case 'cube':
	                cloud = Create$4(length);
	                valid = true;
	                break;
	            case 'map':
	                [cloud, length] = Create(length);
	                valid = true;
	                break;
	            case 'bunny': {
	                const response = await fetch('https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/bunny.pcd');
	                const content = await (await response.blob()).arrayBuffer();
	                const result = Create$2(content);
	                if (result != undefined) {
	                    [cloud, length] = result;
	                    valid = true;
	                }
	                else {
	                    alert('pcd error');
	                }
	                break;
	            }
	            case 'statue':
	                const response = await fetch('https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/rops_cloud.pcd');
	                const content = await (await response.blob()).arrayBuffer();
	                const result = Create$2(content);
	                if (result != undefined) {
	                    [cloud, length] = result;
	                    valid = true;
	                }
	                else {
	                    alert('pcd error');
	                }
	                break;
	            case 'upload':
	                const input = document.createElement('input');
	                input.type = 'file';
	                input.accept = '.pcd';
	                input.multiple = false;
	                input.onchange = async () => {
	                    if (input.files.length == 0) {
	                        alert('please select file');
	                        return;
	                    }
	                    const file = input.files[0];
	                    const result = Create$2(await file.arrayBuffer());
	                    if (result != undefined) {
	                        [cloud, length] = result;
	                        valid = true;
	                    }
	                    else {
	                        alert('pcd error');
	                    }
	                };
	                input.click();
	        }
	        colors = Create$5(length);
	        if (nearest != undefined) {
	            nearest.destroy();
	            nearest = undefined;
	        }
	        if (normals != undefined) {
	            normals.destroy();
	            normals = undefined;
	        }
	        if (curvature != undefined) {
	            curvature.destroy();
	            curvature = undefined;
	        }
	        mode.value = 'points';
	        color.value = 'color';
	    };
	    window.ShowText = (text) => {
	        const hint = document.createElement('div');
	        hint.textContent = text;
	        hint.className = 'hint';
	        document.body.append(hint);
	        setTimeout(() => {
	            hint.remove();
	        }, 5000);
	    };
	    window.StartCompute = async (name) => {
	        switch (name) {
	            case 'kNearestList':
	            case 'kNearestIter':
	            case 'kNearestListSorted':
	            case 'kNearestIterSorted':
	                if (nearest != undefined) {
	                    nearest.destroy();
	                }
	                const kDiv = document.getElementById('k');
	                k = parseInt(kDiv.value);
	                nearest = CreateEmptyBuffer(length * k * 4, GPUBufferUsage.STORAGE);
	                switch (name) {
	                    case 'kNearestList':
	                    case 'kNearestIter':
	                        Compute(name, length, [[k], []], [cloud, nearest]);
	                        break;
	                    case 'kNearestListSorted':
	                    case 'kNearestIterSorted':
	                        await Sort(cloud, length);
	                        Compute(name, length, [[k], []], [cloud, nearest]);
	                        break;
	                }
	                mode.value = 'connections';
	                break;
	            case 'triangulateAll':
	                k = K;
	                if (nearest != undefined) {
	                    nearest.destroy();
	                }
	                nearest = CreateEmptyBuffer(length * k * 4, GPUBufferUsage.STORAGE);
	                Compute('triangulateAll', length, [[], []], [cloud, nearest]);
	                mode.value = 'connections';
	                break;
	            case 'triangulateNear':
	                if (nearest == undefined) {
	                    alert('please calculate nearest first');
	                }
	                else {
	                    const copy = CreateEmptyBuffer(length * K * 4, GPUBufferUsage.STORAGE);
	                    Compute('triangulateNearest', length, [[k], []], [cloud, nearest, copy]);
	                    nearest.destroy();
	                    nearest = copy;
	                    k = K;
	                    mode.value = 'connections';
	                    break;
	                }
	                break;
	            case 'cleanDang':
	            case 'cleanLong':
	                if (nearest == undefined) {
	                    alert('please calculate the connections first');
	                    break;
	                }
	                const newNearest = CreateEmptyBuffer(length * k * 4, GPUBufferUsage.STORAGE);
	                switch (name) {
	                    case 'cleanDang':
	                        Compute('cleanDang', length, [[k], []], [nearest, newNearest]);
	                        break;
	                    case 'cleanLong':
	                        Compute('cleanLong', length, [[k], []], [cloud, nearest, newNearest]);
	                        break;
	                }
	                nearest.destroy();
	                nearest = newNearest;
	                mode.value = 'connections';
	                break;
	            case 'normalPlane':
	            case 'normalTriang':
	                if (nearest == undefined) {
	                    alert('please calculate the connections first');
	                    break;
	                }
	                if (normals == undefined) {
	                    normals = CreateEmptyBuffer(length * 16, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	                }
	                switch (name) {
	                    case 'normalPlane':
	                        Compute('normalLinear', length, [[k], []], [cloud, nearest, normals]);
	                        break;
	                    case 'normalTriang':
	                        Compute('normalTriang', length, [[k], []], [cloud, nearest, normals]);
	                        break;
	                }
	                color.value = 'normal';
	                break;
	            case 'curvaturePoints':
	            case 'curvatureNormal':
	                if (normals == undefined) {
	                    alert('please calculate the normals first');
	                    break;
	                }
	                if (curvature == undefined) {
	                    curvature = CreateEmptyBuffer(length * 16, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
	                }
	                switch (name) {
	                    case 'curvatureNormal':
	                        Compute('curvatureNormal', length, [[k], []], [cloud, nearest, normals, curvature]);
	                        break;
	                    case 'curvaturePoints':
	                        Compute('curvaturePoints', length, [[k], []], [cloud, nearest, normals, curvature]);
	                        break;
	                }
	                color.value = 'curve';
	                break;
	            case 'filterCurve':
	            case 'filterAnomaly':
	                if (curvature == undefined) {
	                    alert('please calculate curvature first');
	                    break;
	                }
	                const tDiv = document.getElementById('threshhold');
	                const t = parseFloat(tDiv.value);
	                const newCloud = CreateEmptyBuffer(length * 16, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	                const newColor = CreateEmptyBuffer(length * 16, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	                let com;
	                switch (name) {
	                    case 'filterCurve':
	                        com = 'reduceLow';
	                        break;
	                    case 'filterAnomaly':
	                        com = 'reduceAnomaly';
	                        break;
	                }
	                const result = Compute(com, length, [[0], [t]], [cloud, colors, curvature, newCloud, newColor], true);
	                length = new Uint32Array(await ReadBuffer(result, 3 * 4))[1];
	                console.log('length:', length);
	                result.destroy();
	                cloud.destroy();
	                colors.destroy();
	                nearest.destroy();
	                normals.destroy();
	                curvature.destroy();
	                cloud = newCloud;
	                colors = newColor;
	                nearest = undefined;
	                normals = undefined;
	                curvature = undefined;
	                color.value = 'color';
	                mode.value = 'points';
	                break;
	            case 'noise':
	                if (curvature == undefined) {
	                    alert('please calculate the curvature first');
	                    break;
	                }
	                const copy = CreateEmptyBuffer(length * 16, GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);
	                Compute('noise', length, [[k], [1.0]], [cloud, normals, curvature, copy]);
	                cloud.destroy();
	                cloud = copy;
	                break;
	            default:
	                alert('wrong name: ' + name);
	        }
	    };
	    display.onwheel = (ev) => {
	        const scale = 1 + ev.deltaY / 1000;
	        increase.Scale(scale, scale, scale);
	        ev.preventDefault();
	        ev.stopImmediatePropagation();
	    };
	    document.body.onresize = () => {
	        Resize(display.clientWidth, display.clientHeight);
	        cam.UpdateSize();
	    };
	    const keys = {};
	    document.body.onkeydown = (ev) => {
	        keys[ev.code] = true;
	    };
	    document.body.onkeyup = (ev) => {
	        delete keys[ev.code];
	    };
	    display.onmousemove = (ev) => {
	        if ((ev.buttons & 1) != 0) {
	            cam.RotateX(-ev.movementY / 200);
	            cam.RotateGlobalY(-ev.movementX / 200);
	        }
	    };
	    let last = await new Promise(requestAnimationFrame);
	    const run = true;
	    const radDiv = document.getElementById('radius');
	    while (run) {
	        const time = await new Promise(requestAnimationFrame);
	        const delta = time - last;
	        if (delta < 50) {
	            const dist = delta / 50;
	            const move = (key, x, y, z) => {
	                if (keys[key] != undefined) {
	                    cam.Translate(x * dist, y * dist, z * dist);
	                }
	            };
	            move('KeyW', 0, 0, -1);
	            move('KeyA', -1, 0, 0);
	            move('KeyS', 0, 0, 1);
	            move('KeyD', 1, 0, 0);
	        }
	        let c = undefined;
	        switch (color.value) {
	            case 'color':
	                c = colors;
	                break;
	            case 'normal':
	                if (normals == undefined) {
	                    c = colors;
	                    color.value = 'color';
	                    alert('normals not calculated');
	                }
	                else {
	                    c = normals;
	                }
	                break;
	            case 'curve':
	                if (curvature == undefined) {
	                    c = colors;
	                    color.value = 'color';
	                    alert('curvature not calculated');
	                }
	                else {
	                    c = curvature;
	                }
	                break;
	        }
	        const rad = parseFloat(radDiv.value);
	        StartRender(cam);
	        if (gridCheckbox.checked) {
	            Render$3(normal, grid.length, grid.positions, grid.colors);
	        }
	        if (valid) {
	            switch (mode.value) {
	                case 'points':
	                    Render$2(increase, rad, length, cloud, c);
	                    break;
	                case 'connections':
	                    if (nearest == undefined) {
	                        mode.value = 'points';
	                        Render$2(increase, rad, length, cloud, c);
	                        alert('connections not calculated');
	                    }
	                    else {
	                        Render$1(increase, cloud, c, nearest, k, length);
	                    }
	                    break;
	                case 'polygons':
	                    if (nearest == undefined) {
	                        mode.value = 'points';
	                        Render$2(increase, rad, length, cloud, c);
	                        alert('connections not calculated');
	                    }
	                    else {
	                        Render(increase, cloud, c, nearest, k, length);
	                    }
	                    break;
	            }
	        }
	        FinishRender();
	        last = time;
	        if (keys['KeyP'] != undefined) {
	            const name = prompt('Please enter file name', 'cloud');
	            if (name != null && name.length > 0) {
	                const link = document.createElement('a');
	                link.download = name + '.png';
	                link.href = canvas.toDataURL();
	                link.click();
	            }
	            delete keys['KeyP'];
	        }
	    }
	};

})();
